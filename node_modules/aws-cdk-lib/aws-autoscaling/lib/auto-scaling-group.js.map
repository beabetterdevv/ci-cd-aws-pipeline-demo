{
  "version": 3,
  "sources": ["auto-scaling-group.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as ec2 from '../../aws-ec2';\nimport * as elb from '../../aws-elasticloadbalancing';\nimport * as elbv2 from '../../aws-elasticloadbalancingv2';\nimport * as iam from '../../aws-iam';\nimport * as sns from '../../aws-sns';\n\nimport {\n  Annotations,\n  Aspects,\n  Aws,\n  CfnAutoScalingRollingUpdate, CfnCreationPolicy, CfnUpdatePolicy,\n  Duration, Fn, IResource, Lazy, PhysicalName, Resource, Stack, Tags,\n  Token,\n  Tokenization, withResolved,\n} from '../../core';\nimport { Construct } from 'constructs';\nimport { AutoScalingGroupRequireImdsv2Aspect } from './aspects';\nimport { CfnAutoScalingGroup, CfnAutoScalingGroupProps, CfnLaunchConfiguration } from './autoscaling.generated';\nimport { BasicLifecycleHookProps, LifecycleHook } from './lifecycle-hook';\nimport { BasicScheduledActionProps, ScheduledAction } from './scheduled-action';\nimport { BasicStepScalingPolicyProps, StepScalingPolicy } from './step-scaling-policy';\nimport { BaseTargetTrackingProps, PredefinedMetric, TargetTrackingScalingPolicy } from './target-tracking-scaling-policy';\nimport { TerminationPolicy } from './termination-policy';\nimport { BlockDevice, BlockDeviceVolume, EbsDeviceVolumeType } from './volume';\n\n/**\n * Name tag constant\n */\nconst NAME_TAG: string = 'Name';\n\n                                                                             \nexport enum Monitoring {\n                                                  \n  BASIC,\n\n                                               \n  DETAILED,\n}\n\n                                                                                                                                                                                                                                                       \nexport interface CommonAutoScalingGroupProps {\n                                                                              \n  readonly minCapacity?: number;\n\n                                                                                            \n  readonly maxCapacity?: number;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly desiredCapacity?: number;\n\n                                                                                                                      \n  readonly keyName?: string;\n\n                                                                                                  \n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n                                                                                                                                                                          \n  readonly notificationsTopic?: sns.ITopic;\n\n                                                                                                                                                                                                                                                                                                                   \n  readonly notifications?: NotificationConfiguration[];\n\n                                                                                                              \n  readonly allowAllOutbound?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly updateType?: UpdateType;\n\n                                                                                                                                                                                                                            \n  readonly rollingUpdateConfiguration?: RollingUpdateConfiguration;\n\n                                                                                                                                                                                                                                                                                               \n  readonly replacingUpdateMinSuccessfulInstancesPercent?: number;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly ignoreUnmodifiedSizeProperties?: boolean;\n\n                                                                                                                                                                                                                         \n  readonly resourceSignalCount?: number;\n\n                                                                                                                                                                                                                                                    \n  readonly resourceSignalTimeout?: Duration;\n\n                                                                                                          \n  readonly cooldown?: Duration;\n\n                                                                                                                                                                \n  readonly associatePublicIpAddress?: boolean;\n\n                                                                                                                                                                                                                                               \n  readonly spotPrice?: string;\n\n                                                                                                          \n  readonly healthCheck?: HealthCheck;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \n  readonly blockDevices?: BlockDevice[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly maxInstanceLifetime?: Duration;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n  readonly instanceMonitoring?: Monitoring;\n\n                                                                                                                                                                                                                                                                                                                               \n  readonly groupMetrics?: GroupMetrics[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  readonly signals?: Signals;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n  readonly updatePolicy?: UpdatePolicy;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  readonly newInstancesProtectedFromScaleIn?: boolean;\n\n                                                                                                                                                      \n  readonly autoScalingGroupName?: string;\n\n                                                                                                                                                                                                                                                                                                                      \n  readonly terminationPolicies?: TerminationPolicy[];\n}\n\n                                \nexport interface AutoScalingGroupProps extends CommonAutoScalingGroupProps {\n                                                  \n  readonly vpc: ec2.IVpc;\n\n                                           \n  readonly instanceType: ec2.InstanceType;\n\n                              \n  readonly machineImage: ec2.IMachineImage;\n\n                                                                                                                                      \n  readonly securityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                                                                                 \n  readonly userData?: ec2.UserData;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly role?: iam.IRole;\n\n                                                                                                                                                                                                                                                                                                                                                \n  readonly init?: ec2.CloudFormationInit;\n\n                                                                                                                                                                              \n  readonly initOptions?: ApplyCloudFormationInitOptions;\n\n                                                                                                    \n  readonly requireImdsv2?: boolean;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                   \nexport abstract class Signals {\n                                                                                                                                                                                                                                                                                                                                                                  \n  public static waitForAll(options: SignalsOptions = {}): Signals {\n    validatePercentage(options.minSuccessPercentage);\n    return new class extends Signals {\n      public renderCreationPolicy(renderOptions: RenderSignalsOptions): CfnCreationPolicy {\n        return this.doRender(options, renderOptions.desiredCapacity ?? renderOptions.minCapacity);\n      }\n    }();\n  }\n\n                                                                                                                                                                                                                                                                    \n  public static waitForMinCapacity(options: SignalsOptions = {}): Signals {\n    validatePercentage(options.minSuccessPercentage);\n    return new class extends Signals {\n      public renderCreationPolicy(renderOptions: RenderSignalsOptions): CfnCreationPolicy {\n        return this.doRender(options, renderOptions.minCapacity);\n      }\n    }();\n  }\n\n                                                                                                                                                                                                                                                                                                                                                       \n  public static waitForCount(count: number, options: SignalsOptions = {}): Signals {\n    validatePercentage(options.minSuccessPercentage);\n    return new class extends Signals {\n      public renderCreationPolicy(): CfnCreationPolicy {\n        return this.doRender(options, count);\n      }\n    }();\n  }\n\n                                                \n  public abstract renderCreationPolicy(renderOptions: RenderSignalsOptions): CfnCreationPolicy;\n\n                                                                                                        \n  protected doRender(options: SignalsOptions, count?: number): CfnCreationPolicy {\n    const minSuccessfulInstancesPercent = validatePercentage(options.minSuccessPercentage);\n    return {\n      ...options.minSuccessPercentage !== undefined ? { autoScalingCreationPolicy: { minSuccessfulInstancesPercent } } : { },\n      resourceSignal: {\n        count,\n        timeout: options.timeout?.toIsoString(),\n      },\n    };\n  }\n\n}\n\n                                                 \nexport interface RenderSignalsOptions {\n                                                                                                    \n  readonly desiredCapacity?: number;\n\n                                                                                       \n  readonly minCapacity?: number;\n}\n\n                                                    \nexport interface SignalsOptions {\n                                                                                                                                                                                                                                                            \n  readonly minSuccessPercentage?: number;\n\n                                                                                                                                                                                                                                                     \n  readonly timeout?: Duration;\n}\n\n                                                   \nexport abstract class UpdatePolicy {\n                                                                    \n  public static replacingUpdate(): UpdatePolicy {\n    return new class extends UpdatePolicy {\n      public _renderUpdatePolicy(): CfnUpdatePolicy {\n        return {\n          autoScalingReplacingUpdate: { willReplace: true },\n        };\n      }\n    }();\n  }\n\n                                                                                        \n  public static rollingUpdate(options: RollingUpdateOptions = {}): UpdatePolicy {\n    const minSuccessPercentage = validatePercentage(options.minSuccessPercentage);\n\n    return new class extends UpdatePolicy {\n      public _renderUpdatePolicy(renderOptions: RenderUpdateOptions): CfnUpdatePolicy {\n        return {\n          autoScalingRollingUpdate: {\n            maxBatchSize: options.maxBatchSize,\n            minInstancesInService: options.minInstancesInService,\n            suspendProcesses: options.suspendProcesses ?? DEFAULT_SUSPEND_PROCESSES,\n            minSuccessfulInstancesPercent:\n              minSuccessPercentage ?? renderOptions.creationPolicy?.autoScalingCreationPolicy?.minSuccessfulInstancesPercent,\n            waitOnResourceSignals: options.waitOnResourceSignals ?? renderOptions.creationPolicy?.resourceSignal !== undefined ? true : undefined,\n            pauseTime: options.pauseTime?.toIsoString() ?? renderOptions.creationPolicy?.resourceSignal?.timeout,\n          },\n        };\n      }\n    }();\n  }\n\n  /**\n   * Render the ASG's CreationPolicy\n   * @internal\n   */\n  public abstract _renderUpdatePolicy(renderOptions: RenderUpdateOptions): CfnUpdatePolicy;\n}\n\n/**\n * Options for rendering UpdatePolicy\n */\ninterface RenderUpdateOptions {\n  /**\n   * The Creation Policy already created\n   *\n   * @default - no CreationPolicy configured\n   */\n  readonly creationPolicy?: CfnCreationPolicy;\n}\n\n                                                     \nexport interface RollingUpdateOptions {\n                                                                                                                                                                          \n  readonly maxBatchSize?: number;\n\n                                                                                                                                                                                             \n  readonly minInstancesInService?: number;\n\n                                                                                                                                                                                                                                                                                           \n  readonly suspendProcesses?: ScalingProcess[];\n\n                                                                                                                                                                                                            \n  readonly waitOnResourceSignals?: boolean;\n\n                                                                                                                                                                  \n  readonly pauseTime?: Duration;\n\n                                                                                                                                                                                                 \n  readonly minSuccessPercentage?: number;\n}\n\n                                 \nexport class GroupMetrics {\n\n                                          \n  public static all(): GroupMetrics {\n    return new GroupMetrics();\n  }\n\n  /**\n   * @internal\n   */\n  public _metrics = new Set<GroupMetric>();\n\n  constructor(...metrics: GroupMetric[]) {\n    metrics?.forEach(metric => this._metrics.add(metric));\n  }\n}\n\n                                                                               \nexport class GroupMetric {\n\n                                                           \n  public static readonly MIN_SIZE = new GroupMetric('GroupMinSize');\n\n                                                           \n  public static readonly MAX_SIZE = new GroupMetric('GroupMaxSize');\n\n                                                                                         \n  public static readonly DESIRED_CAPACITY = new GroupMetric('GroupDesiredCapacity');\n\n                                                                                                                                                                       \n  public static readonly IN_SERVICE_INSTANCES = new GroupMetric('GroupInServiceInstances');\n\n                                                                                                                                                                                  \n  public static readonly PENDING_INSTANCES = new GroupMetric('GroupPendingInstances');\n\n                                                                                                                                                   \n  public static readonly STANDBY_INSTANCES = new GroupMetric('GroupStandbyInstances');\n\n                                                                                                                                                          \n  public static readonly TERMINATING_INSTANCES = new GroupMetric('GroupTerminatingInstances');\n\n                                                                                                                                                                          \n  public static readonly TOTAL_INSTANCES = new GroupMetric('GroupTotalInstances');\n\n                                             \n  public readonly name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nabstract class AutoScalingGroupBase extends Resource implements IAutoScalingGroup {\n\n  public abstract autoScalingGroupName: string;\n  public abstract autoScalingGroupArn: string;\n  public abstract readonly osType: ec2.OperatingSystemType;\n  protected albTargetGroup?: elbv2.ApplicationTargetGroup;\n  public readonly grantPrincipal: iam.IPrincipal = new iam.UnknownPrincipal({ resource: this });\n\n                                                                                                      \n  public addLifecycleHook(id: string, props: BasicLifecycleHookProps): LifecycleHook {\n    return new LifecycleHook(this, `LifecycleHook${id}`, {\n      autoScalingGroup: this,\n      ...props,\n    });\n  }\n\n                                              \n  public scaleOnSchedule(id: string, props: BasicScheduledActionProps): ScheduledAction {\n    return new ScheduledAction(this, `ScheduledAction${id}`, {\n      autoScalingGroup: this,\n      ...props,\n    });\n  }\n\n                                                                    \n  public scaleOnCpuUtilization(id: string, props: CpuUtilizationScalingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ASG_AVERAGE_CPU_UTILIZATION,\n      targetValue: props.targetUtilizationPercent,\n      ...props,\n    });\n  }\n\n                                                                         \n  public scaleOnIncomingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ASG_AVERAGE_NETWORK_IN,\n      targetValue: props.targetBytesPerSecond,\n      ...props,\n    });\n  }\n\n                                                                        \n  public scaleOnOutgoingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ASG_AVERAGE_NETWORK_OUT,\n      targetValue: props.targetBytesPerSecond,\n      ...props,\n    });\n  }\n\n                                                                                                                                                                                                        \n  public scaleOnRequestCount(id: string, props: RequestCountScalingProps): TargetTrackingScalingPolicy {\n    if (this.albTargetGroup === undefined) {\n      throw new Error('Attach the AutoScalingGroup to a non-imported Application Load Balancer before calling scaleOnRequestCount()');\n    }\n\n    const resourceLabel = `${this.albTargetGroup.firstLoadBalancerFullName}/${this.albTargetGroup.targetGroupFullName}`;\n\n    if ((props.targetRequestsPerMinute === undefined) === (props.targetRequestsPerSecond === undefined)) {\n      throw new Error('Specify exactly one of \\'targetRequestsPerMinute\\' or \\'targetRequestsPerSecond\\'');\n    }\n\n    let rpm: number;\n    if (props.targetRequestsPerSecond !== undefined) {\n      if (Token.isUnresolved(props.targetRequestsPerSecond)) {\n        throw new Error('\\'targetRequestsPerSecond\\' cannot be an unresolved value; use \\'targetRequestsPerMinute\\' instead.');\n      }\n      rpm = props.targetRequestsPerSecond * 60;\n    } else {\n      rpm = props.targetRequestsPerMinute!;\n    }\n\n    const policy = new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ALB_REQUEST_COUNT_PER_TARGET,\n      targetValue: rpm,\n      resourceLabel,\n      ...props,\n    });\n\n    policy.node.addDependency(this.albTargetGroup.loadBalancerAttached);\n    return policy;\n  }\n\n                                                                                \n  public scaleToTrackMetric(id: string, props: MetricTargetTrackingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      customMetric: props.metric,\n      ...props,\n    });\n  }\n\n                                                         \n  public scaleOnMetric(id: string, props: BasicStepScalingPolicyProps): StepScalingPolicy {\n    return new StepScalingPolicy(this, id, { ...props, autoScalingGroup: this });\n  }\n\n  public addUserData(..._commands: string[]): void {\n    // do nothing\n  }\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                                                         \nexport class AutoScalingGroup extends AutoScalingGroupBase implements\n  elb.ILoadBalancerTarget,\n  ec2.IConnectable,\n  elbv2.IApplicationLoadBalancerTarget,\n  elbv2.INetworkLoadBalancerTarget {\n\n  public static fromAutoScalingGroupName(scope: Construct, id: string, autoScalingGroupName: string): IAutoScalingGroup {\n    class Import extends AutoScalingGroupBase {\n      public autoScalingGroupName = autoScalingGroupName;\n      public autoScalingGroupArn = Stack.of(this).formatArn({\n        service: 'autoscaling',\n        resource: 'autoScalingGroup:*:autoScalingGroupName',\n        resourceName: this.autoScalingGroupName,\n      });\n      public readonly osType = ec2.OperatingSystemType.UNKNOWN;\n    }\n\n    return new Import(scope, id);\n  }\n\n                                                                    \n  public readonly osType: ec2.OperatingSystemType;\n\n                                                                                       \n  public readonly connections: ec2.Connections;\n\n                                                                 \n  public readonly role: iam.IRole;\n\n                                                      \n  public readonly grantPrincipal: iam.IPrincipal;\n\n                                             \n  public readonly autoScalingGroupName: string;\n\n                                            \n  public readonly autoScalingGroupArn: string;\n\n                                           \n  public readonly userData: ec2.UserData;\n\n                                                                                                                                                 \n  public readonly spotPrice?: string;\n\n                                                                               \n  public readonly maxInstanceLifetime?: Duration;\n\n  private readonly autoScalingGroup: CfnAutoScalingGroup;\n  private readonly securityGroup: ec2.ISecurityGroup;\n  private readonly securityGroups: ec2.ISecurityGroup[] = [];\n  private readonly loadBalancerNames: string[] = [];\n  private readonly targetGroupArns: string[] = [];\n  private readonly groupMetrics: GroupMetrics[] = [];\n  private readonly notifications: NotificationConfiguration[] = [];\n\n  protected newInstancesProtectedFromScaleIn?: boolean;\n\n  constructor(scope: Construct, id: string, props: AutoScalingGroupProps) {\n    super(scope, id, {\n      physicalName: props.autoScalingGroupName,\n    });\n\n    this.newInstancesProtectedFromScaleIn = props.newInstancesProtectedFromScaleIn;\n\n    if (props.initOptions && !props.init) {\n      throw new Error('Setting \\'initOptions\\' requires that \\'init\\' is also set');\n    }\n\n    this.securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'InstanceSecurityGroup', {\n      vpc: props.vpc,\n      allowAllOutbound: props.allowAllOutbound !== false,\n    });\n    this.connections = new ec2.Connections({ securityGroups: [this.securityGroup] });\n    this.securityGroups.push(this.securityGroup);\n    Tags.of(this).add(NAME_TAG, this.node.path);\n\n    this.role = props.role || new iam.Role(this, 'InstanceRole', {\n      roleName: PhysicalName.GENERATE_IF_NEEDED,\n      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),\n    });\n\n    this.grantPrincipal = this.role;\n\n    if (props.groupMetrics) {\n      this.groupMetrics.push(...props.groupMetrics);\n    }\n\n    const iamProfile = new iam.CfnInstanceProfile(this, 'InstanceProfile', {\n      roles: [this.role.roleName],\n    });\n\n    // use delayed evaluation\n    const imageConfig = props.machineImage.getImage(this);\n    this.userData = props.userData ?? imageConfig.userData;\n    const userDataToken = Lazy.string({ produce: () => Fn.base64(this.userData.render()) });\n    const securityGroupsToken = Lazy.list({ produce: () => this.securityGroups.map(sg => sg.securityGroupId) });\n\n    const launchConfig = new CfnLaunchConfiguration(this, 'LaunchConfig', {\n      imageId: imageConfig.imageId,\n      keyName: props.keyName,\n      instanceType: props.instanceType.toString(),\n      instanceMonitoring: (props.instanceMonitoring !== undefined ? (props.instanceMonitoring === Monitoring.DETAILED) : undefined),\n      securityGroups: securityGroupsToken,\n      iamInstanceProfile: iamProfile.ref,\n      userData: userDataToken,\n      associatePublicIpAddress: props.associatePublicIpAddress,\n      spotPrice: props.spotPrice,\n      blockDeviceMappings: (props.blockDevices !== undefined ?\n        synthesizeBlockDeviceMappings(this, props.blockDevices) : undefined),\n    });\n\n    launchConfig.node.addDependency(this.role);\n\n    // desiredCapacity just reflects what the user has supplied.\n    const desiredCapacity = props.desiredCapacity;\n    const minCapacity = props.minCapacity ?? 1;\n    const maxCapacity = props.maxCapacity ?? desiredCapacity ?? Math.max(minCapacity, 1);\n\n    withResolved(minCapacity, maxCapacity, (min, max) => {\n      if (min > max) {\n        throw new Error(`minCapacity (${min}) should be <= maxCapacity (${max})`);\n      }\n    });\n    withResolved(desiredCapacity, minCapacity, (desired, min) => {\n      if (desired === undefined) { return; }\n      if (desired < min) {\n        throw new Error(`Should have minCapacity (${min}) <= desiredCapacity (${desired})`);\n      }\n    });\n    withResolved(desiredCapacity, maxCapacity, (desired, max) => {\n      if (desired === undefined) { return; }\n      if (max < desired) {\n        throw new Error(`Should have desiredCapacity (${desired}) <= maxCapacity (${max})`);\n      }\n    });\n\n    if (desiredCapacity !== undefined) {\n      Annotations.of(this).addWarning('desiredCapacity has been configured. Be aware this will reset the size of your AutoScalingGroup on every deployment. See https://github.com/aws/aws-cdk/issues/5215');\n    }\n\n    this.maxInstanceLifetime = props.maxInstanceLifetime;\n    if (this.maxInstanceLifetime &&\n      (this.maxInstanceLifetime.toSeconds() < 604800 || this.maxInstanceLifetime.toSeconds() > 31536000)) {\n      throw new Error('maxInstanceLifetime must be between 7 and 365 days (inclusive)');\n    }\n\n    if (props.notificationsTopic && props.notifications) {\n      throw new Error('Cannot set \\'notificationsTopic\\' and \\'notifications\\', \\'notificationsTopic\\' is deprecated use \\'notifications\\' instead');\n    }\n\n    if (props.notificationsTopic) {\n      this.notifications = [{\n        topic: props.notificationsTopic,\n      }];\n    }\n\n    if (props.notifications) {\n      this.notifications = props.notifications.map(nc => ({\n        topic: nc.topic,\n        scalingEvents: nc.scalingEvents ?? ScalingEvents.ALL,\n      }));\n    }\n\n    const { subnetIds, hasPublic } = props.vpc.selectSubnets(props.vpcSubnets);\n    const asgProps: CfnAutoScalingGroupProps = {\n      autoScalingGroupName: this.physicalName,\n      cooldown: props.cooldown?.toSeconds().toString(),\n      minSize: Tokenization.stringifyNumber(minCapacity),\n      maxSize: Tokenization.stringifyNumber(maxCapacity),\n      desiredCapacity: desiredCapacity !== undefined ? Tokenization.stringifyNumber(desiredCapacity) : undefined,\n      launchConfigurationName: launchConfig.ref,\n      loadBalancerNames: Lazy.list({ produce: () => this.loadBalancerNames }, { omitEmpty: true }),\n      targetGroupArns: Lazy.list({ produce: () => this.targetGroupArns }, { omitEmpty: true }),\n      notificationConfigurations: this.renderNotificationConfiguration(),\n      metricsCollection: Lazy.any({ produce: () => this.renderMetricsCollection() }),\n      vpcZoneIdentifier: subnetIds,\n      healthCheckType: props.healthCheck && props.healthCheck.type,\n      healthCheckGracePeriod: props.healthCheck && props.healthCheck.gracePeriod && props.healthCheck.gracePeriod.toSeconds(),\n      maxInstanceLifetime: this.maxInstanceLifetime ? this.maxInstanceLifetime.toSeconds() : undefined,\n      newInstancesProtectedFromScaleIn: Lazy.any({ produce: () => this.newInstancesProtectedFromScaleIn }),\n      terminationPolicies: props.terminationPolicies,\n    };\n\n    if (!hasPublic && props.associatePublicIpAddress) {\n      throw new Error(\"To set 'associatePublicIpAddress: true' you must select Public subnets (vpcSubnets: { subnetType: SubnetType.PUBLIC })\");\n    }\n\n    this.autoScalingGroup = new CfnAutoScalingGroup(this, 'ASG', asgProps);\n    this.osType = imageConfig.osType;\n    this.autoScalingGroupName = this.getResourceNameAttribute(this.autoScalingGroup.ref),\n    this.autoScalingGroupArn = Stack.of(this).formatArn({\n      service: 'autoscaling',\n      resource: 'autoScalingGroup:*:autoScalingGroupName',\n      resourceName: this.autoScalingGroupName,\n    });\n    this.node.defaultChild = this.autoScalingGroup;\n\n    this.applyUpdatePolicies(props, { desiredCapacity, minCapacity });\n    if (props.init) {\n      this.applyCloudFormationInit(props.init, props.initOptions);\n    }\n\n    this.spotPrice = props.spotPrice;\n\n    if (props.requireImdsv2) {\n      Aspects.of(this).add(new AutoScalingGroupRequireImdsv2Aspect());\n    }\n  }\n\n                                                                                                                                                                           \n  public addSecurityGroup(securityGroup: ec2.ISecurityGroup): void {\n    this.securityGroups.push(securityGroup);\n  }\n\n                                                  \n  public attachToClassicLB(loadBalancer: elb.LoadBalancer): void {\n    this.loadBalancerNames.push(loadBalancer.loadBalancerName);\n  }\n\n                                                         \n  public attachToApplicationTargetGroup(targetGroup: elbv2.IApplicationTargetGroup): elbv2.LoadBalancerTargetProps {\n    if (this.albTargetGroup !== undefined) {\n      throw new Error('Cannot add AutoScalingGroup to 2nd Target Group');\n    }\n\n    this.targetGroupArns.push(targetGroup.targetGroupArn);\n    if (targetGroup instanceof elbv2.ApplicationTargetGroup) {\n      // Copy onto self if it's a concrete type. We need this for autoscaling\n      // based on request count, which we cannot do with an imported TargetGroup.\n      this.albTargetGroup = targetGroup;\n    }\n\n    targetGroup.registerConnectable(this);\n    return { targetType: elbv2.TargetType.INSTANCE };\n  }\n\n                                                         \n  public attachToNetworkTargetGroup(targetGroup: elbv2.INetworkTargetGroup): elbv2.LoadBalancerTargetProps {\n    this.targetGroupArns.push(targetGroup.targetGroupArn);\n    return { targetType: elbv2.TargetType.INSTANCE };\n  }\n\n  public addUserData(...commands: string[]): void {\n    this.userData.addCommands(...commands);\n  }\n\n                                                                                     \n  public addToRolePolicy(statement: iam.PolicyStatement) {\n    this.role.addToPrincipalPolicy(statement);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                             \n  public applyCloudFormationInit(init: ec2.CloudFormationInit, options: ApplyCloudFormationInitOptions = {}) {\n    if (!this.autoScalingGroup.cfnOptions.creationPolicy?.resourceSignal) {\n      throw new Error('When applying CloudFormationInit, you must also configure signals by supplying \\'signals\\' at instantiation time.');\n    }\n\n    init.attach(this.autoScalingGroup, {\n      platform: this.osType,\n      instanceRole: this.role,\n      userData: this.userData,\n      configSets: options.configSets,\n      embedFingerprint: options.embedFingerprint,\n      printLog: options.printLog,\n      ignoreFailures: options.ignoreFailures,\n      includeRole: options.includeRole,\n      includeUrl: options.includeUrl,\n    });\n  }\n\n                                                                              \n  public protectNewInstancesFromScaleIn() {\n    this.newInstancesProtectedFromScaleIn = true;\n  }\n\n                                                                                        \n  public areNewInstancesProtectedFromScaleIn(): boolean {\n    return this.newInstancesProtectedFromScaleIn === true;\n  }\n\n  /**\n   * Apply CloudFormation update policies for the AutoScalingGroup\n   */\n  private applyUpdatePolicies(props: AutoScalingGroupProps, signalOptions: RenderSignalsOptions) {\n    // Make sure people are not using the old and new properties together\n    const oldProps: Array<keyof AutoScalingGroupProps> = [\n      'updateType',\n      'rollingUpdateConfiguration',\n      'resourceSignalCount',\n      'resourceSignalTimeout',\n      'replacingUpdateMinSuccessfulInstancesPercent',\n    ];\n    for (const prop of oldProps) {\n      if ((props.signals || props.updatePolicy) && props[prop] !== undefined) {\n        throw new Error(`Cannot set 'signals'/'updatePolicy' and '${prop}' together. Prefer 'signals'/'updatePolicy'`);\n      }\n    }\n\n    // Reify updatePolicy to `rollingUpdate` default in case it is combined with `init`\n    props = {\n      ...props,\n      updatePolicy: props.updatePolicy ?? (props.init ? UpdatePolicy.rollingUpdate() : undefined),\n    };\n\n    if (props.signals || props.updatePolicy) {\n      this.applyNewSignalUpdatePolicies(props, signalOptions);\n    } else {\n      this.applyLegacySignalUpdatePolicies(props);\n    }\n\n    // The following is technically part of the \"update policy\" but it's also a completely\n    // separate aspect of rolling/replacing update, so it's just its own top-level property.\n    // Default is 'true' because that's what you're most likely to want\n    if (props.ignoreUnmodifiedSizeProperties !== false) {\n      this.autoScalingGroup.cfnOptions.updatePolicy = {\n        ...this.autoScalingGroup.cfnOptions.updatePolicy,\n        autoScalingScheduledAction: { ignoreUnmodifiedGroupSizeProperties: true },\n      };\n    }\n\n    if (props.signals && !props.init) {\n      // To be able to send a signal using `cfn-init`, the execution role needs\n      // `cloudformation:SignalResource`. Normally the binding of CfnInit would\n      // grant that permissions and another one, but if the user wants to use\n      // `signals` without `init`, add the permissions here.\n      //\n      // If they call `applyCloudFormationInit()` after construction, nothing bad\n      // happens either, we'll just have a duplicate statement which doesn't hurt.\n      this.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['cloudformation:SignalResource'],\n        resources: [Aws.STACK_ID],\n      }));\n    }\n  }\n\n  /**\n   * Use 'signals' and 'updatePolicy' to determine the creation and update policies\n   */\n  private applyNewSignalUpdatePolicies(props: AutoScalingGroupProps, signalOptions: RenderSignalsOptions) {\n    this.autoScalingGroup.cfnOptions.creationPolicy = props.signals?.renderCreationPolicy(signalOptions);\n    this.autoScalingGroup.cfnOptions.updatePolicy = props.updatePolicy?._renderUpdatePolicy({\n      creationPolicy: this.autoScalingGroup.cfnOptions.creationPolicy,\n    });\n  }\n\n  private applyLegacySignalUpdatePolicies(props: AutoScalingGroupProps) {\n    if (props.updateType === UpdateType.REPLACING_UPDATE) {\n      this.autoScalingGroup.cfnOptions.updatePolicy = {\n        ...this.autoScalingGroup.cfnOptions.updatePolicy,\n        autoScalingReplacingUpdate: {\n          willReplace: true,\n        },\n      };\n\n      if (props.replacingUpdateMinSuccessfulInstancesPercent !== undefined) {\n        // Yes, this goes on CreationPolicy, not as a process parameter to ReplacingUpdate.\n        // It's a little confusing, but the docs seem to explicitly state it will only be used\n        // during the update?\n        //\n        // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-creationpolicy.html\n        this.autoScalingGroup.cfnOptions.creationPolicy = {\n          ...this.autoScalingGroup.cfnOptions.creationPolicy,\n          autoScalingCreationPolicy: {\n            minSuccessfulInstancesPercent: validatePercentage(props.replacingUpdateMinSuccessfulInstancesPercent),\n          },\n        };\n      }\n    } else if (props.updateType === UpdateType.ROLLING_UPDATE) {\n      this.autoScalingGroup.cfnOptions.updatePolicy = {\n        ...this.autoScalingGroup.cfnOptions.updatePolicy,\n        autoScalingRollingUpdate: renderRollingUpdateConfig(props.rollingUpdateConfiguration),\n      };\n    }\n\n    if (props.resourceSignalCount !== undefined || props.resourceSignalTimeout !== undefined) {\n      this.autoScalingGroup.cfnOptions.creationPolicy = {\n        ...this.autoScalingGroup.cfnOptions.creationPolicy,\n        resourceSignal: {\n          count: props.resourceSignalCount,\n          timeout: props.resourceSignalTimeout && props.resourceSignalTimeout.toIsoString(),\n        },\n      };\n    }\n  }\n\n  private renderNotificationConfiguration(): CfnAutoScalingGroup.NotificationConfigurationProperty[] | undefined {\n    if (this.notifications.length === 0) {\n      return undefined;\n    }\n\n    return this.notifications.map(notification => ({\n      topicArn: notification.topic.topicArn,\n      notificationTypes: notification.scalingEvents ? notification.scalingEvents._types : ScalingEvents.ALL._types,\n    }));\n  }\n\n  private renderMetricsCollection(): CfnAutoScalingGroup.MetricsCollectionProperty[] | undefined {\n    if (this.groupMetrics.length === 0) {\n      return undefined;\n    }\n\n    return this.groupMetrics.map(group => ({\n      granularity: '1Minute',\n      metrics: group._metrics?.size !== 0 ? [...group._metrics].map(m => m.name) : undefined,\n    }));\n  }\n}\n\n                                                                                                                         \nexport enum UpdateType {\n                                  \n  NONE = 'None',\n\n                                                                                                                            \n  REPLACING_UPDATE = 'Replace',\n\n                                                               \n  ROLLING_UPDATE = 'RollingUpdate',\n}\n\n                                                                                                                                                                            \nexport interface NotificationConfiguration {\n                                                                           \n  readonly topic: sns.ITopic;\n\n                                                                                                   \n  readonly scalingEvents?: ScalingEvents;\n}\n\n                               \nexport enum ScalingEvent {\n                                                     \n  INSTANCE_LAUNCH = 'autoscaling:EC2_INSTANCE_LAUNCH',\n\n                                                       \n  INSTANCE_TERMINATE = 'autoscaling:EC2_INSTANCE_TERMINATE',\n\n                                                            \n  INSTANCE_TERMINATE_ERROR = 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR',\n\n                                                         \n  INSTANCE_LAUNCH_ERROR = 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR',\n\n                                                      \n  TEST_NOTIFICATION = 'autoscaling:TEST_NOTIFICATION'\n}\n\n                                                                                                                  \nexport interface RollingUpdateConfiguration {\n                                                                                                              \n  readonly maxBatchSize?: number;\n\n                                                                                                                                                                                             \n  readonly minInstancesInService?: number;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n  readonly minSuccessfulInstancesPercent?: number;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly pauseTime?: Duration;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  readonly waitOnResourceSignals?: boolean;\n\n                                                                                                                                                                                                                                                                                           \n  readonly suspendProcesses?: ScalingProcess[];\n}\n\n                                                                                                                                                                                                                                                      \nexport class ScalingEvents {\n                                     \n  public static readonly ERRORS = new ScalingEvents(ScalingEvent.INSTANCE_LAUNCH_ERROR, ScalingEvent.INSTANCE_TERMINATE_ERROR);\n\n                                         \n  public static readonly ALL = new ScalingEvents(ScalingEvent.INSTANCE_LAUNCH,\n    ScalingEvent.INSTANCE_LAUNCH_ERROR,\n    ScalingEvent.INSTANCE_TERMINATE,\n    ScalingEvent.INSTANCE_TERMINATE_ERROR);\n\n                                            \n  public static readonly LAUNCH_EVENTS = new ScalingEvents(ScalingEvent.INSTANCE_LAUNCH, ScalingEvent.INSTANCE_LAUNCH_ERROR);\n\n                                                \n  public static readonly TERMINATION_EVENTS = new ScalingEvents(ScalingEvent.INSTANCE_TERMINATE, ScalingEvent.INSTANCE_TERMINATE_ERROR);\n\n\n  /**\n   * @internal\n   */\n  public readonly _types: ScalingEvent[];\n\n  constructor(...types: ScalingEvent[]) {\n    this._types = types;\n  }\n}\n\nexport enum ScalingProcess {\n  LAUNCH = 'Launch',\n  TERMINATE = 'Terminate',\n  HEALTH_CHECK = 'HealthCheck',\n  REPLACE_UNHEALTHY = 'ReplaceUnhealthy',\n  AZ_REBALANCE = 'AZRebalance',\n  ALARM_NOTIFICATION = 'AlarmNotification',\n  SCHEDULED_ACTIONS = 'ScheduledActions',\n  ADD_TO_LOAD_BALANCER = 'AddToLoadBalancer'\n}\n\n// Recommended list of processes to suspend from here:\n// https://aws.amazon.com/premiumsupport/knowledge-center/auto-scaling-group-rolling-updates/\nconst DEFAULT_SUSPEND_PROCESSES = [ScalingProcess.HEALTH_CHECK, ScalingProcess.REPLACE_UNHEALTHY, ScalingProcess.AZ_REBALANCE,\n  ScalingProcess.ALARM_NOTIFICATION, ScalingProcess.SCHEDULED_ACTIONS];\n\n                                  \nexport interface Ec2HealthCheckOptions {\n                                                                                                                                                                             \n  readonly grace?: Duration;\n}\n\n                                  \nexport interface ElbHealthCheckOptions {\n                                                                                                                                                                                               \n  readonly grace: Duration;\n}\n\n                                \nexport class HealthCheck {\n                                                                                            \n  public static ec2(options: Ec2HealthCheckOptions = {}): HealthCheck {\n    return new HealthCheck(HealthCheckType.EC2, options.grace);\n  }\n\n                                                                                                                                                                                                                   \n  public static elb(options: ElbHealthCheckOptions): HealthCheck {\n    return new HealthCheck(HealthCheckType.ELB, options.grace);\n  }\n\n  private constructor(public readonly type: string, public readonly gracePeriod?: Duration) { }\n}\n\nenum HealthCheckType {\n  EC2 = 'EC2',\n  ELB = 'ELB',\n}\n\n/**\n * Render the rolling update configuration into the appropriate object\n */\nfunction renderRollingUpdateConfig(config: RollingUpdateConfiguration = {}): CfnAutoScalingRollingUpdate {\n  const waitOnResourceSignals = config.minSuccessfulInstancesPercent !== undefined;\n  const pauseTime = config.pauseTime || (waitOnResourceSignals ? Duration.minutes(5) : Duration.seconds(0));\n\n  return {\n    maxBatchSize: config.maxBatchSize,\n    minInstancesInService: config.minInstancesInService,\n    minSuccessfulInstancesPercent: validatePercentage(config.minSuccessfulInstancesPercent),\n    waitOnResourceSignals,\n    pauseTime: pauseTime && pauseTime.toIsoString(),\n    suspendProcesses: config.suspendProcesses ?? DEFAULT_SUSPEND_PROCESSES,\n  };\n}\n\nfunction validatePercentage(x?: number): number | undefined {\n  if (x === undefined || (0 <= x && x <= 100)) { return x; }\n  throw new Error(`Expected: a percentage 0..100, got: ${x}`);\n}\n\n                              \nexport interface IAutoScalingGroup extends IResource, iam.IGrantable {\n                                                                 \n  readonly autoScalingGroupName: string;\n\n                                                                \n  readonly autoScalingGroupArn: string;\n\n                                                                                                                                          \n  readonly osType: ec2.OperatingSystemType;\n\n                                                                                                                                                                                                                \n  addUserData(...commands: string[]): void;\n\n                                                                                                      \n  addLifecycleHook(id: string, props: BasicLifecycleHookProps): LifecycleHook;\n\n                                              \n  scaleOnSchedule(id: string, props: BasicScheduledActionProps): ScheduledAction;\n\n                                                                    \n  scaleOnCpuUtilization(id: string, props: CpuUtilizationScalingProps): TargetTrackingScalingPolicy;\n\n                                                                         \n  scaleOnIncomingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy;\n\n                                                                        \n  scaleOnOutgoingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy;\n\n                                                                                \n  scaleToTrackMetric(id: string, props: MetricTargetTrackingProps): TargetTrackingScalingPolicy;\n\n                                                         \n  scaleOnMetric(id: string, props: BasicStepScalingPolicyProps): StepScalingPolicy;\n}\n\n                                                                   \nexport interface CpuUtilizationScalingProps extends BaseTargetTrackingProps {\n                                                               \n  readonly targetUtilizationPercent: number;\n}\n\n                                                                       \nexport interface NetworkUtilizationScalingProps extends BaseTargetTrackingProps {\n                                                              \n  readonly targetBytesPerSecond: number;\n}\n\n                                                                  \nexport interface RequestCountScalingProps extends BaseTargetTrackingProps {\n                                                                                                                                                                                                                            \n  readonly targetRequestsPerSecond?: number;\n\n                                                                                                                                                               \n  readonly targetRequestsPerMinute?: number;\n}\n\n                                                                  \nexport interface MetricTargetTrackingProps extends BaseTargetTrackingProps {\n                                                                                                                                                                                                            \n  readonly metric: cloudwatch.IMetric;\n\n                                                \n  readonly targetValue: number;\n}\n\n/**\n * Synthesize an array of block device mappings from a list of block device\n *\n * @param construct the instance/asg construct, used to host any warning\n * @param blockDevices list of block devices\n */\nfunction synthesizeBlockDeviceMappings(construct: Construct, blockDevices: BlockDevice[]): CfnLaunchConfiguration.BlockDeviceMappingProperty[] {\n  return blockDevices.map<CfnLaunchConfiguration.BlockDeviceMappingProperty>(({ deviceName, volume, mappingEnabled }) => {\n    const { virtualName, ebsDevice: ebs } = volume;\n\n    if (volume === BlockDeviceVolume._NO_DEVICE || mappingEnabled === false) {\n      return {\n        deviceName,\n        noDevice: true,\n      };\n    }\n\n    if (ebs) {\n      const { iops, volumeType } = ebs;\n\n      if (!iops) {\n        if (volumeType === EbsDeviceVolumeType.IO1) {\n          throw new Error('iops property is required with volumeType: EbsDeviceVolumeType.IO1');\n        }\n      } else if (volumeType !== EbsDeviceVolumeType.IO1) {\n        Annotations.of(construct).addWarning('iops will be ignored without volumeType: EbsDeviceVolumeType.IO1');\n      }\n    }\n\n    return {\n      deviceName, ebs, virtualName,\n    };\n  });\n}\n\n                                                                                    \nexport interface ApplyCloudFormationInitOptions {\n                                                                     \n  readonly configSets?: string[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly embedFingerprint?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly printLog?: boolean;\n\n                                                                                                                                                                                                                                 \n  readonly ignoreFailures?: boolean;\n\n                                                                                                                                                                                                                                                 \n  readonly includeUrl?: boolean;\n\n                                                                                                                                                                                      \n  readonly includeRole?: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
