{
  "version": 3,
  "sources": ["stream.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport { ArnFormat, Aws, CfnCondition, Duration, Fn, IResolvable, IResource, Resource, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { KinesisMetrics } from './kinesis-fixed-canned-metrics';\nimport { CfnStream } from './kinesis.generated';\n\nconst READ_OPERATIONS = [\n  'kinesis:DescribeStreamSummary',\n  'kinesis:GetRecords',\n  'kinesis:GetShardIterator',\n  'kinesis:ListShards',\n  'kinesis:SubscribeToShard',\n  'kinesis:DescribeStream',\n  'kinesis:ListStreams',\n];\n\nconst WRITE_OPERATIONS = [\n  'kinesis:ListShards',\n  'kinesis:PutRecord',\n  'kinesis:PutRecords',\n];\n\n                           \nexport interface IStream extends IResource {\n                                                            \n  readonly streamArn: string;\n\n                                                            \n  readonly streamName: string;\n\n                                                                         \n  readonly encryptionKey?: kms.IKey;\n\n                                                                                                                                                                                                                                                       \n  grantRead(grantee: iam.IGrantable): iam.Grant;\n\n                                                                                                                                                                                                                                                        \n  grantWrite(grantee: iam.IGrantable): iam.Grant;\n\n                                                                                                                                                                                                                                            \n  grantReadWrite(grantee: iam.IGrantable): iam.Grant;\n\n                                                                                              \n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n                                                                                                                                                                 \n  metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  metricGetRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                             \n  metricGetRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  metricGetRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                               \n  metricGetRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  metricIncomingBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n  metricIncomingRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                       \n  metricPutRecordBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                            \n  metricPutRecordLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                             \n  metricPutRecordSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                        \n  metricPutRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                             \n  metricPutRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                        \n  metricPutRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                             \n  metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                             \n  metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                           \n  metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                             \n  metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n}\n\n                                                                                                                                                                                \nexport interface StreamAttributes {\n                                       \n  readonly streamArn: string;\n\n                                                                                                                             \n  readonly encryptionKey?: kms.IKey;\n}\n\n/**\n * Represents a Kinesis Stream.\n */\nabstract class StreamBase extends Resource implements IStream {\n  /**\n   * The ARN of the stream.\n   */\n  public abstract readonly streamArn: string;\n\n  /**\n   * The name of the stream\n   */\n  public abstract readonly streamName: string;\n\n  /**\n   * Optional KMS encryption key associated with this stream.\n   */\n  public abstract readonly encryptionKey?: kms.IKey;\n\n                                                                                                                                                                                                                                                       \n  public grantRead(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, ...READ_OPERATIONS);\n\n    if (this.encryptionKey) {\n      this.encryptionKey.grantDecrypt(grantee);\n    }\n\n    return ret;\n  }\n\n                                                                                                                                                                                                                                                        \n  public grantWrite(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, ...WRITE_OPERATIONS);\n    this.encryptionKey?.grantEncrypt(grantee);\n\n    return ret;\n  }\n\n                                                                                                                                                                                                                                            \n  public grantReadWrite(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, ...Array.from(new Set([...READ_OPERATIONS, ...WRITE_OPERATIONS])));\n    this.encryptionKey?.grantEncryptDecrypt(grantee);\n\n    return ret;\n  }\n\n                                                                                                             \n  public grant(grantee: iam.IGrantable, ...actions: string[]) {\n    return iam.Grant.addToPrincipal({\n      grantee,\n      actions,\n      resourceArns: [this.streamArn],\n      scope: this,\n    });\n  }\n\n                                                                                                                                                                 \n  public metric(metricName: string, props?: cloudwatch.MetricOptions) {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/Kinesis',\n      metricName,\n      dimensionsMap: {\n        StreamName: this.streamName,\n      },\n      ...props,\n    }).attachTo(this);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  public metricGetRecordsBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsBytesAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  public metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsIteratorAgeMillisecondsMaximum, props);\n  }\n\n                                                                                                                                                                                                                                                                                               \n  public metricGetRecordsSuccess(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsSuccessAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  public metricGetRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsRecordsAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                               \n  public metricGetRecordsLatency(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsLatencyAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                       \n  public metricPutRecordBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordBytesAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                            \n  metricPutRecordLatency(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordLatencyAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                             \n  public metricPutRecordSuccess(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordSuccessAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                        \n  public metricPutRecordsBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsBytesAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                             \n  public metricPutRecordsLatency(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsLatencyAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                        \n  public metricPutRecordsSuccess(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsSuccessAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                             \n  public metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsTotalRecordsAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                             \n  public metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsSuccessfulRecordsAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                           \n  public metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsFailedRecordsAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                             \n  public metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsThrottledRecordsAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  public metricIncomingBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.incomingBytesAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n  public metricIncomingRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.incomingRecordsAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  public metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.readProvisionedThroughputExceededAverage, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  public metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.writeProvisionedThroughputExceededAverage, props);\n  }\n\n  // create metrics based on generated KinesisMetrics static methods\n  private metricFromCannedFunction(\n    createCannedProps: (dimensions: { StreamName: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...createCannedProps({ StreamName: this.streamName }),\n      ...props,\n    }).attachTo(this);\n  }\n\n}\n\n                                          \nexport interface StreamProps {\n                                                                                      \n  readonly streamName?: string;\n\n                                                                                                                                          \n  readonly retentionPeriod?: Duration;\n\n                                                                                                                                       \n  readonly shardCount?: number;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly encryption?: StreamEncryption;\n\n                                                                                                                                                                                                                                                                                                                                                                \n  readonly encryptionKey?: kms.IKey;\n\n                                                                                            \n  readonly streamMode?: StreamMode;\n}\n\n                                                             \nexport class Stream extends StreamBase {\n\n                                                                                                                                                                                                                                                                      \n  public static fromStreamArn(scope: Construct, id: string, streamArn: string): IStream {\n    return Stream.fromStreamAttributes(scope, id, { streamArn });\n  }\n\n                                                                                                                                                                                                                                      \n  public static fromStreamAttributes(scope: Construct, id: string, attrs: StreamAttributes): IStream {\n    class Import extends StreamBase {\n      public readonly streamArn = attrs.streamArn;\n      public readonly streamName = Stack.of(scope).splitArn(attrs.streamArn, ArnFormat.SLASH_RESOURCE_NAME).resourceName!;\n      public readonly encryptionKey = attrs.encryptionKey;\n    }\n\n    return new Import(scope, id);\n  }\n\n  public readonly streamArn: string;\n  public readonly streamName: string;\n  public readonly encryptionKey?: kms.IKey;\n\n  private readonly stream: CfnStream;\n\n  constructor(scope: Construct, id: string, props: StreamProps = {}) {\n    super(scope, id, {\n      physicalName: props.streamName,\n    });\n\n    let shardCount = props.shardCount;\n    const streamMode = props.streamMode ?? StreamMode.PROVISIONED;\n\n    if (streamMode === StreamMode.ON_DEMAND && shardCount !== undefined) {\n      throw new Error(`streamMode must be set to ${StreamMode.PROVISIONED} (default) when specifying shardCount`);\n    }\n    if (streamMode === StreamMode.PROVISIONED && shardCount === undefined) {\n      shardCount = 1;\n    }\n\n    const retentionPeriodHours = props.retentionPeriod?.toHours() ?? 24;\n    if (!Token.isUnresolved(retentionPeriodHours)) {\n      if (retentionPeriodHours < 24 || retentionPeriodHours > 8760) {\n        throw new Error(`retentionPeriod must be between 24 and 8760 hours. Received ${retentionPeriodHours}`);\n      }\n    }\n\n    const { streamEncryption, encryptionKey } = this.parseEncryption(props);\n\n    this.stream = new CfnStream(this, 'Resource', {\n      name: this.physicalName,\n      retentionPeriodHours,\n      shardCount,\n      streamEncryption,\n      streamModeDetails: streamMode ? { streamMode } : undefined,\n    });\n\n    this.streamArn = this.getResourceArnAttribute(this.stream.attrArn, {\n      service: 'kinesis',\n      resource: 'stream',\n      resourceName: this.physicalName,\n    });\n    this.streamName = this.getResourceNameAttribute(this.stream.ref);\n\n    this.encryptionKey = encryptionKey;\n  }\n\n  /**\n   * Set up key properties and return the Stream encryption property from the\n   * user's configuration.\n   */\n  private parseEncryption(props: StreamProps): {\n    streamEncryption?: CfnStream.StreamEncryptionProperty | IResolvable\n    encryptionKey?: kms.IKey\n  } {\n\n    // if encryption properties are not set, default to KMS in regions where KMS is available\n    if (!props.encryption && !props.encryptionKey) {\n\n      const conditionName = 'AwsCdkKinesisEncryptedStreamsUnsupportedRegions';\n      const existing = Stack.of(this).node.tryFindChild(conditionName);\n\n      // create a single condition for the Stack\n      if (!existing) {\n        new CfnCondition(Stack.of(this), conditionName, {\n          expression: Fn.conditionOr(\n            Fn.conditionEquals(Aws.REGION, 'cn-north-1'),\n            Fn.conditionEquals(Aws.REGION, 'cn-northwest-1'),\n          ),\n        });\n      }\n\n      return {\n        streamEncryption: Fn.conditionIf(conditionName,\n          Aws.NO_VALUE,\n          { EncryptionType: 'KMS', KeyId: 'alias/aws/kinesis' }),\n      };\n    }\n\n    // default based on whether encryption key is specified\n    const encryptionType = props.encryption ??\n      (props.encryptionKey ? StreamEncryption.KMS : StreamEncryption.UNENCRYPTED);\n\n    // if encryption key is set, encryption must be set to KMS.\n    if (encryptionType !== StreamEncryption.KMS && props.encryptionKey) {\n      throw new Error(`encryptionKey is specified, so 'encryption' must be set to KMS (value: ${encryptionType})`);\n    }\n\n    if (encryptionType === StreamEncryption.UNENCRYPTED) {\n      return { };\n    }\n\n    if (encryptionType === StreamEncryption.MANAGED) {\n      const encryption = { encryptionType: 'KMS', keyId: 'alias/aws/kinesis' };\n      return { streamEncryption: encryption };\n    }\n\n    if (encryptionType === StreamEncryption.KMS) {\n      const encryptionKey = props.encryptionKey || new kms.Key(this, 'Key', {\n        description: `Created by ${this.node.path}`,\n      });\n\n      const streamEncryption: CfnStream.StreamEncryptionProperty = {\n        encryptionType: 'KMS',\n        keyId: encryptionKey.keyArn,\n      };\n      return { encryptionKey, streamEncryption };\n    }\n\n    throw new Error(`Unexpected 'encryptionType': ${encryptionType}`);\n  }\n}\n\n                                                                      \nexport enum StreamEncryption {\n                                                         \n  UNENCRYPTED = 'NONE',\n\n                                                                                                                                                                        \n  KMS = 'KMS',\n\n                                                                                   \n  MANAGED = 'MANAGED'\n}\n\n                                                               \nexport enum StreamMode {\n                                                                                                                                                                               \n  PROVISIONED = 'PROVISIONED',\n\n                                                                                                                                                          \n  ON_DEMAND = 'ON_DEMAND'\n}\n"],
  "mappings": "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",
  "names": []
}
