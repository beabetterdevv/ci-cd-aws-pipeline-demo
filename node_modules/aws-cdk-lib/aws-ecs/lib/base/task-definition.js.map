{
  "version": 3,
  "sources": ["task-definition.ts"],
  "sourcesContent": ["import * as ec2 from '../../../aws-ec2';\nimport * as iam from '../../../aws-iam';\nimport { IResource, Lazy, Names, PhysicalName, Resource } from '../../../core';\nimport { Construct } from 'constructs';\nimport { ContainerDefinition, ContainerDefinitionOptions, PortMapping, Protocol } from '../container-definition';\nimport { CfnTaskDefinition } from '../ecs.generated';\nimport { FirelensLogRouter, FirelensLogRouterDefinitionOptions, FirelensLogRouterType, obtainDefaultFluentBitECRImage } from '../firelens-log-router';\nimport { AwsLogDriver } from '../log-drivers/aws-log-driver';\nimport { PlacementConstraint } from '../placement';\nimport { ProxyConfiguration } from '../proxy-configuration/proxy-configuration';\nimport { RuntimePlatform } from '../runtime-platform';\nimport { ImportedTaskDefinition } from './_imported-task-definition';\n\n                                                  \nexport interface ITaskDefinition extends IResource {\n                                                            \n  readonly taskDefinitionArn: string;\n\n                                                        \n  readonly executionRole?: iam.IRole;\n\n                                                                                  \n  readonly compatibility: Compatibility;\n\n                                                                                \n  readonly isEc2Compatible: boolean;\n\n                                                                                   \n  readonly isFargateCompatible: boolean;\n\n                                                                                        \n  readonly isExternalCompatible: boolean;\n\n\n                                                                           \n  readonly networkMode: NetworkMode;\n\n                                                                                                                        \n  readonly taskRole: iam.IRole;\n}\n\n                                                                                                                                                                                                                  \nexport interface CommonTaskDefinitionProps {\n                                                                                                                                                                                            \n  readonly family?: string;\n\n                                                                                                                                                                                                                                                                                                                                                          \n  readonly executionRole?: iam.IRole;\n\n                                                                                                                                                                                           \n  readonly taskRole?: iam.IRole;\n\n                                                                                                               \n  readonly proxyConfiguration?: ProxyConfiguration;\n\n                                                                                                                                                                                                                                                                                                                                \n  readonly volumes?: Volume[];\n}\n\n                                               \nexport interface TaskDefinitionProps extends CommonTaskDefinitionProps {\n                                                                                                                                                                                                                                           \n  readonly networkMode?: NetworkMode;\n\n                                                                                                                                                                                                                                                                                                                            \n  readonly placementConstraints?: PlacementConstraint[];\n\n                                                               \n  readonly compatibility: Compatibility;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  readonly cpu?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n  readonly memoryMiB?: string;\n\n                                                                                                                                                                                                            \n  readonly ipcMode?: IpcMode;\n\n                                                                                                                                                                                                       \n  readonly pidMode?: PidMode;\n\n                                                                                                                                                                      \n  readonly inferenceAccelerators?: InferenceAccelerator[];\n\n                                                                                                                                                                                                                                                         \n  readonly ephemeralStorageGiB?: number;\n\n                                                                                                                                                                                                       \n  readonly runtimePlatform?: RuntimePlatform;\n}\n\n                                                                                           \nexport interface CommonTaskDefinitionAttributes {\n                                               \n  readonly taskDefinitionArn: string;\n\n                                                                                                                                                    \n  readonly networkMode?: NetworkMode;\n\n                                                                                                                                                                                               \n  readonly taskRole?: iam.IRole;\n}\n\n                                                      \nexport interface TaskDefinitionAttributes extends CommonTaskDefinitionAttributes {\n                                                                                                                                   \n  readonly compatibility?: Compatibility;\n}\n\nabstract class TaskDefinitionBase extends Resource implements ITaskDefinition {\n\n  public abstract readonly compatibility: Compatibility;\n  public abstract readonly networkMode: NetworkMode;\n  public abstract readonly taskDefinitionArn: string;\n  public abstract readonly taskRole: iam.IRole;\n  public abstract readonly executionRole?: iam.IRole;\n\n                                                                                \n  public get isEc2Compatible(): boolean {\n    return isEc2Compatible(this.compatibility);\n  }\n\n                                                                                   \n  public get isFargateCompatible(): boolean {\n    return isFargateCompatible(this.compatibility);\n  }\n\n                                                                                        \n  public get isExternalCompatible(): boolean {\n    return isExternalCompatible(this.compatibility);\n  }\n}\n\n                                                   \nexport class TaskDefinition extends TaskDefinitionBase {\n\n                                                                                                                                               \n  public static fromTaskDefinitionArn(scope: Construct, id: string, taskDefinitionArn: string): ITaskDefinition {\n    return new ImportedTaskDefinition(scope, id, { taskDefinitionArn: taskDefinitionArn });\n  }\n\n                                                                          \n  public static fromTaskDefinitionAttributes(scope: Construct, id: string, attrs: TaskDefinitionAttributes): ITaskDefinition {\n    return new ImportedTaskDefinition(scope, id, {\n      taskDefinitionArn: attrs.taskDefinitionArn,\n      compatibility: attrs.compatibility,\n      networkMode: attrs.networkMode,\n      taskRole: attrs.taskRole,\n    });\n  }\n\n                                                                                                                                              \n  public readonly family: string;\n\n                                                                                            \n  public readonly taskDefinitionArn: string;\n\n                                                                                                                        \n  public readonly taskRole: iam.IRole;\n\n                                                                           \n  public readonly networkMode: NetworkMode;\n\n                                                                                                                                                                                                                    \n  public defaultContainer?: ContainerDefinition;\n\n                                                                \n  public readonly compatibility: Compatibility;\n\n                                                                                                                                                           \n  public readonly ephemeralStorageGiB?: number;\n\n                                           \n  protected readonly containers = new Array<ContainerDefinition>();\n\n  /**\n   * All volumes\n   */\n  private readonly volumes: Volume[] = [];\n\n  /**\n   * Placement constraints for task instances\n   */\n  private readonly placementConstraints = new Array<CfnTaskDefinition.TaskDefinitionPlacementConstraintProperty>();\n\n  /**\n   * Inference accelerators for task instances\n   */\n  private readonly _inferenceAccelerators: InferenceAccelerator[] = [];\n\n  private _executionRole?: iam.IRole;\n\n  private _referencesSecretJsonField?: boolean;\n\n  private runtimePlatform?: RuntimePlatform;\n\n                                                                       \n  constructor(scope: Construct, id: string, props: TaskDefinitionProps) {\n    super(scope, id);\n\n    this.family = props.family || Names.uniqueId(this);\n    this.compatibility = props.compatibility;\n\n    if (props.volumes) {\n      props.volumes.forEach(v => this.addVolume(v));\n    }\n\n    this.networkMode = props.networkMode ?? (this.isFargateCompatible ? NetworkMode.AWS_VPC : NetworkMode.BRIDGE);\n    if (this.isFargateCompatible && this.networkMode !== NetworkMode.AWS_VPC) {\n      throw new Error(`Fargate tasks can only have AwsVpc network mode, got: ${this.networkMode}`);\n    }\n    if (props.proxyConfiguration && this.networkMode !== NetworkMode.AWS_VPC) {\n      throw new Error(`ProxyConfiguration can only be used with AwsVpc network mode, got: ${this.networkMode}`);\n    }\n    if (props.placementConstraints && props.placementConstraints.length > 0 && this.isFargateCompatible) {\n      throw new Error('Cannot set placement constraints on tasks that run on Fargate');\n    }\n\n    if (this.isFargateCompatible && (!props.cpu || !props.memoryMiB)) {\n      throw new Error(`Fargate-compatible tasks require both CPU (${props.cpu}) and memory (${props.memoryMiB}) specifications`);\n    }\n\n    if (props.inferenceAccelerators && props.inferenceAccelerators.length > 0 && this.isFargateCompatible) {\n      throw new Error('Cannot use inference accelerators on tasks that run on Fargate');\n    }\n\n    if (this.isExternalCompatible && this.networkMode !== NetworkMode.BRIDGE) {\n      throw new Error(`External tasks can only have Bridge network mode, got: ${this.networkMode}`);\n    }\n\n    if (!this.isFargateCompatible && props.runtimePlatform) {\n      throw new Error('Cannot specify runtimePlatform in non-Fargate compatible tasks');\n    }\n\n    this._executionRole = props.executionRole;\n\n    this.taskRole = props.taskRole || new iam.Role(this, 'TaskRole', {\n      assumedBy: new iam.ServicePrincipal('ecs-tasks.amazonaws.com'),\n    });\n\n    if (props.inferenceAccelerators) {\n      props.inferenceAccelerators.forEach(ia => this.addInferenceAccelerator(ia));\n    }\n\n    this.ephemeralStorageGiB = props.ephemeralStorageGiB;\n\n    // validate the cpu and memory size for the Windows operation system family.\n    if (props.runtimePlatform?.operatingSystemFamily?._operatingSystemFamily.includes('WINDOWS')) {\n      // We know that props.cpu and props.memoryMiB are defined because an error would have been thrown previously if they were not.\n      // But, typescript is not able to figure this out, so using the `!` operator here to let the type-checker know they are defined.\n      this.checkFargateWindowsBasedTasksSize(props.cpu!, props.memoryMiB!, props.runtimePlatform!);\n    }\n\n    this.runtimePlatform = props.runtimePlatform;\n\n    const taskDef = new CfnTaskDefinition(this, 'Resource', {\n      containerDefinitions: Lazy.any({ produce: () => this.renderContainers() }, { omitEmptyArray: true }),\n      volumes: Lazy.any({ produce: () => this.renderVolumes() }, { omitEmptyArray: true }),\n      executionRoleArn: Lazy.string({ produce: () => this.executionRole && this.executionRole.roleArn }),\n      family: this.family,\n      taskRoleArn: this.taskRole.roleArn,\n      requiresCompatibilities: [\n        ...(isEc2Compatible(props.compatibility) ? ['EC2'] : []),\n        ...(isFargateCompatible(props.compatibility) ? ['FARGATE'] : []),\n        ...(isExternalCompatible(props.compatibility) ? ['EXTERNAL'] : []),\n      ],\n      networkMode: this.renderNetworkMode(this.networkMode),\n      placementConstraints: Lazy.any({\n        produce: () =>\n          !isFargateCompatible(this.compatibility) ? this.placementConstraints : undefined,\n      }, { omitEmptyArray: true }),\n      proxyConfiguration: props.proxyConfiguration ? props.proxyConfiguration.bind(this.stack, this) : undefined,\n      cpu: props.cpu,\n      memory: props.memoryMiB,\n      ipcMode: props.ipcMode,\n      pidMode: props.pidMode,\n      inferenceAccelerators: Lazy.any({\n        produce: () =>\n          !isFargateCompatible(this.compatibility) ? this.renderInferenceAccelerators() : undefined,\n      }, { omitEmptyArray: true }),\n      ephemeralStorage: this.ephemeralStorageGiB ? {\n        sizeInGiB: this.ephemeralStorageGiB,\n      } : undefined,\n      runtimePlatform: this.isFargateCompatible && this.runtimePlatform ? {\n        cpuArchitecture: this.runtimePlatform?.cpuArchitecture?._cpuArchitecture,\n        operatingSystemFamily: this.runtimePlatform?.operatingSystemFamily?._operatingSystemFamily,\n      } : undefined,\n    });\n\n    if (props.placementConstraints) {\n      props.placementConstraints.forEach(pc => this.addPlacementConstraint(pc));\n    }\n\n    this.taskDefinitionArn = taskDef.ref;\n    this.node.addValidation({ validate: () => this.validateTaskDefinition() });\n  }\n\n  public get executionRole(): iam.IRole | undefined {\n    return this._executionRole;\n  }\n\n                                                                                                        \n  public get inferenceAccelerators(): InferenceAccelerator[] {\n    return this._inferenceAccelerators;\n  }\n\n  private renderVolumes(): CfnTaskDefinition.VolumeProperty[] {\n    return this.volumes.map(renderVolume);\n\n    function renderVolume(spec: Volume): CfnTaskDefinition.VolumeProperty {\n      return {\n        host: spec.host,\n        name: spec.name,\n        dockerVolumeConfiguration: spec.dockerVolumeConfiguration && {\n          autoprovision: spec.dockerVolumeConfiguration.autoprovision,\n          driver: spec.dockerVolumeConfiguration.driver,\n          driverOpts: spec.dockerVolumeConfiguration.driverOpts,\n          labels: spec.dockerVolumeConfiguration.labels,\n          scope: spec.dockerVolumeConfiguration.scope,\n        },\n        efsVolumeConfiguration: spec.efsVolumeConfiguration && {\n          fileSystemId: spec.efsVolumeConfiguration.fileSystemId,\n          authorizationConfig: spec.efsVolumeConfiguration.authorizationConfig,\n          rootDirectory: spec.efsVolumeConfiguration.rootDirectory,\n          transitEncryption: spec.efsVolumeConfiguration.transitEncryption,\n          transitEncryptionPort: spec.efsVolumeConfiguration.transitEncryptionPort,\n\n        },\n      };\n    }\n  }\n\n  private renderInferenceAccelerators(): CfnTaskDefinition.InferenceAcceleratorProperty[] {\n    return this._inferenceAccelerators.map(renderInferenceAccelerator);\n\n    function renderInferenceAccelerator(inferenceAccelerator: InferenceAccelerator) : CfnTaskDefinition.InferenceAcceleratorProperty {\n      return {\n        deviceName: inferenceAccelerator.deviceName,\n        deviceType: inferenceAccelerator.deviceType,\n      };\n    }\n  }\n\n  /**\n   * Validate the existence of the input target and set default values.\n   *\n   * @internal\n   */\n  public _validateTarget(options: LoadBalancerTargetOptions): LoadBalancerTarget {\n    const targetContainer = this.findContainer(options.containerName);\n    if (targetContainer === undefined) {\n      throw new Error(`No container named '${options.containerName}'. Did you call \"addContainer()\"?`);\n    }\n    const targetProtocol = options.protocol || Protocol.TCP;\n    const targetContainerPort = options.containerPort || targetContainer.containerPort;\n    const portMapping = targetContainer.findPortMapping(targetContainerPort, targetProtocol);\n    if (portMapping === undefined) {\n      // eslint-disable-next-line max-len\n      throw new Error(`Container '${targetContainer}' has no mapping for port ${options.containerPort} and protocol ${targetProtocol}. Did you call \"container.addPortMappings()\"?`);\n    }\n    return {\n      containerName: options.containerName,\n      portMapping,\n    };\n  }\n\n  /**\n   * Returns the port range to be opened that match the provided container name and container port.\n   *\n   * @internal\n   */\n  public _portRangeFromPortMapping(portMapping: PortMapping): ec2.Port {\n    if (portMapping.hostPort !== undefined && portMapping.hostPort !== 0) {\n      return portMapping.protocol === Protocol.UDP ? ec2.Port.udp(portMapping.hostPort) : ec2.Port.tcp(portMapping.hostPort);\n    }\n    if (this.networkMode === NetworkMode.BRIDGE || this.networkMode === NetworkMode.NAT) {\n      return EPHEMERAL_PORT_RANGE;\n    }\n    return portMapping.protocol === Protocol.UDP ? ec2.Port.udp(portMapping.containerPort) : ec2.Port.tcp(portMapping.containerPort);\n  }\n\n                                                              \n  public addToTaskRolePolicy(statement: iam.PolicyStatement) {\n    this.taskRole.addToPrincipalPolicy(statement);\n  }\n\n                                                                        \n  public addToExecutionRolePolicy(statement: iam.PolicyStatement) {\n    this.obtainExecutionRole().addToPrincipalPolicy(statement);\n  }\n\n                                                             \n  public addContainer(id: string, props: ContainerDefinitionOptions) {\n    return new ContainerDefinition(this, id, { taskDefinition: this, ...props });\n  }\n\n                                                                   \n  public addFirelensLogRouter(id: string, props: FirelensLogRouterDefinitionOptions) {\n    // only one firelens log router is allowed in each task.\n    if (this.containers.find(x => x instanceof FirelensLogRouter)) {\n      throw new Error('Firelens log router is already added in this task.');\n    }\n\n    return new FirelensLogRouter(this, id, { taskDefinition: this, ...props });\n  }\n\n  /**\n   * Links a container to this task definition.\n   * @internal\n   */\n  public _linkContainer(container: ContainerDefinition) {\n    this.containers.push(container);\n    if (this.defaultContainer === undefined && container.essential) {\n      this.defaultContainer = container;\n    }\n    if (container.referencesSecretJsonField) {\n      this._referencesSecretJsonField = true;\n    }\n  }\n\n                                                      \n  public addVolume(volume: Volume) {\n    this.volumes.push(volume);\n  }\n\n                                                                                \n  public addPlacementConstraint(constraint: PlacementConstraint) {\n    if (isFargateCompatible(this.compatibility)) {\n      throw new Error('Cannot set placement constraints on tasks that run on Fargate');\n    }\n    this.placementConstraints.push(...constraint.toJson());\n  }\n\n                                                                                                                                                                 \n  public addExtension(extension: ITaskDefinitionExtension) {\n    extension.extend(this);\n  }\n\n                                                                      \n  public addInferenceAccelerator(inferenceAccelerator: InferenceAccelerator) {\n    if (isFargateCompatible(this.compatibility)) {\n      throw new Error('Cannot use inference accelerators on tasks that run on Fargate');\n    }\n    this._inferenceAccelerators.push(inferenceAccelerator);\n  }\n\n                                                                                 \n  public obtainExecutionRole(): iam.IRole {\n    if (!this._executionRole) {\n      this._executionRole = new iam.Role(this, 'ExecutionRole', {\n        assumedBy: new iam.ServicePrincipal('ecs-tasks.amazonaws.com'),\n        // needed for cross-account access with TagParameterContainerImage\n        roleName: PhysicalName.GENERATE_IF_NEEDED,\n      });\n    }\n    return this._executionRole;\n  }\n\n                                                                                                                                                        \n  public get referencesSecretJsonField(): boolean | undefined {\n    return this._referencesSecretJsonField;\n  }\n\n  /**\n   * Validates the task definition.\n   */\n  private validateTaskDefinition(): string[] {\n    const ret = new Array<string>();\n\n    if (isEc2Compatible(this.compatibility)) {\n      // EC2 mode validations\n\n      // Container sizes\n      for (const container of this.containers) {\n        if (!container.memoryLimitSpecified) {\n          ret.push(`ECS Container ${container.containerName} must have at least one of 'memoryLimitMiB' or 'memoryReservationMiB' specified`);\n        }\n      }\n    }\n    return ret;\n  }\n\n                                                                             \n  public findContainer(containerName: string): ContainerDefinition | undefined {\n    return this.containers.find(c => c.containerName === containerName);\n  }\n\n  private renderNetworkMode(networkMode: NetworkMode): string | undefined {\n    return (networkMode === NetworkMode.NAT) ? undefined : networkMode;\n  }\n\n  private renderContainers() {\n    // add firelens log router container if any application container is using firelens log driver,\n    // also check if already created log router container\n    for (const container of this.containers) {\n      if (container.logDriverConfig && container.logDriverConfig.logDriver === 'awsfirelens'\n        && !this.containers.find(x => x instanceof FirelensLogRouter)) {\n        this.addFirelensLogRouter('log-router', {\n          image: obtainDefaultFluentBitECRImage(this, container.logDriverConfig),\n          firelensConfig: {\n            type: FirelensLogRouterType.FLUENTBIT,\n          },\n          logging: new AwsLogDriver({ streamPrefix: 'firelens' }),\n          memoryReservationMiB: 50,\n        });\n\n        break;\n      }\n    }\n\n    return this.containers.map(x => x.renderContainerDefinition());\n  }\n\n  private checkFargateWindowsBasedTasksSize(cpu: string, memory: string, runtimePlatform: RuntimePlatform) {\n    if (Number(cpu) === 1024) {\n      if (Number(memory) < 1024 || Number(memory) > 8192 || (Number(memory)% 1024 !== 0)) {\n        throw new Error(`If provided cpu is ${cpu}, then memoryMiB must have a min of 1024 and a max of 8192, in 1024 increments. Provided memoryMiB was ${Number(memory)}.`);\n      }\n    } else if (Number(cpu) === 2048) {\n      if (Number(memory) < 4096 || Number(memory) > 16384 || (Number(memory) % 1024 !== 0)) {\n        throw new Error(`If provided cpu is ${cpu}, then memoryMiB must have a min of 4096 and max of 16384, in 1024 increments. Provided memoryMiB ${Number(memory)}.`);\n      }\n    } else if (Number(cpu) === 4096) {\n      if (Number(memory) < 8192 || Number(memory) > 30720 || (Number(memory) % 1024 !== 0)) {\n        throw new Error(`If provided cpu is ${ cpu }, then memoryMiB must have a min of 8192 and a max of 30720, in 1024 increments.Provided memoryMiB was ${ Number(memory) }.`);\n      }\n    } else {\n      throw new Error(`If operatingSystemFamily is ${runtimePlatform.operatingSystemFamily!._operatingSystemFamily}, then cpu must be in 1024 (1 vCPU), 2048 (2 vCPU), or 4096 (4 vCPU). Provided value was: ${cpu}`);\n    }\n  };\n}\n\n/**\n * The port range to open up for dynamic port mapping\n */\nconst EPHEMERAL_PORT_RANGE = ec2.Port.tcpRange(32768, 65535);\n\n                                                                     \nexport enum NetworkMode {\n                                                                                                                                          \n  NONE = 'none',\n\n                                                                                                               \n  BRIDGE = 'bridge',\n\n                                                                    \n  AWS_VPC = 'awsvpc',\n\n                                                                                                                                                                                                                                                                                                        \n  HOST = 'host',\n\n                                                                                                                                                                                                                                                                                                                                    \n  NAT = 'nat'\n}\n\n                                                                            \nexport enum IpcMode {\n                                                                                                                                                                                      \n  NONE = 'none',\n\n                                                                                                                                                                                                                \n  HOST = 'host',\n\n                                                                                                             \n  TASK = 'task',\n}\n\n                                                                       \nexport enum PidMode {\n                                                                                                                                                                                                                    \n  HOST = 'host',\n\n                                                                                                                 \n  TASK = 'task',\n}\n\n                                                                                                                                                                                  \nexport interface InferenceAccelerator {\n                                                                                     \n  readonly deviceName?: string;\n\n                                                                                                                                                      \n  readonly deviceType?: string;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                              \nexport interface Volume {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n  readonly host?: Host;\n\n                                                                                                                                                                                                                                 \n  readonly name: string;\n\n                                                                                                                                                                                                                                                                                     \n  readonly dockerVolumeConfiguration?: DockerVolumeConfiguration;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n  readonly efsVolumeConfiguration?: EfsVolumeConfiguration;\n}\n\n                                                                      \nexport interface Host {\n                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly sourcePath?: string;\n}\n\n/**\n * Properties for an ECS target.\n *\n * @internal\n */\nexport interface LoadBalancerTarget {\n  /**\n   * The name of the container.\n   */\n  readonly containerName: string;\n\n  /**\n   * The port mapping of the target.\n   */\n  readonly portMapping: PortMapping\n}\n\n                                                                                                                                  \nexport interface LoadBalancerTargetOptions {\n                                           \n  readonly containerName: string;\n\n                                                                                                                                                                                      \n  readonly containerPort?: number;\n\n                                                                                                                                               \n  readonly protocol?: Protocol;\n}\n\n                                                                                                                           \nexport interface DockerVolumeConfiguration {\n                                                                                                                                                                                                   \n  readonly autoprovision?: boolean;\n                                                 \n  readonly driver: string;\n                                                                                                      \n  readonly driverOpts?: {[key: string]: string};\n                                                                                           \n  readonly labels?: { [key: string]: string; }\n                                                                               \n  readonly scope: Scope;\n}\n\n                                                                                  \nexport interface AuthorizationConfig {\n                                                                                                                                                                                                                                                                                          \n  readonly accessPointId?: string;\n                                                                                                                                                                                                                                                                                                                                                                     \n  readonly iam?: string;\n}\n\n                                                              \nexport interface EfsVolumeConfiguration {\n                                                      \n  readonly fileSystemId: string;\n                                                                                                                                                                                                                                             \n  readonly rootDirectory?: string;\n                                                                                                                                                                                                                                                                                                       \n  readonly transitEncryption?: string;\n                                                                                                                                                                                                                                 \n  readonly transitEncryptionPort?: number;\n                                                                                                                             \n  readonly authorizationConfig?: AuthorizationConfig;\n}\n\n                                                                                                                                                                                                                                                                                     \nexport enum Scope {\n                                                                                                                                               \n  TASK = 'task',\n\n                                                                                       \n  SHARED = 'shared'\n}\n\n                                                          \nexport enum Compatibility {\n                                                             \n  EC2,\n\n                                                                 \n  FARGATE,\n\n                                                                             \n  EC2_AND_FARGATE,\n\n                                                                  \n  EXTERNAL\n}\n\n                                                                                                                                                                                                                                                                                                             \nexport interface ITaskDefinitionExtension {\n                                                                                                                                    \n  extend(taskDefinition: TaskDefinition): void;\n}\n\n/**\n * Return true if the given task definition can be run on an EC2 cluster\n */\nexport function isEc2Compatible(compatibility: Compatibility): boolean {\n  return [Compatibility.EC2, Compatibility.EC2_AND_FARGATE].includes(compatibility);\n}\n\n/**\n * Return true if the given task definition can be run on a Fargate cluster\n */\nexport function isFargateCompatible(compatibility: Compatibility): boolean {\n  return [Compatibility.FARGATE, Compatibility.EC2_AND_FARGATE].includes(compatibility);\n}\n\n/**\n * Return true if the given task definition can be run on a ECS Anywhere cluster\n */\nexport function isExternalCompatible(compatibility: Compatibility): boolean {\n  return [Compatibility.EXTERNAL].includes(compatibility);\n}\n"],
  "mappings": "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",
  "names": []
}
