{
  "version": 3,
  "sources": ["base-service.ts"],
  "sourcesContent": ["import * as appscaling from '../../../aws-applicationautoscaling';\nimport * as cloudwatch from '../../../aws-cloudwatch';\nimport * as ec2 from '../../../aws-ec2';\nimport * as elb from '../../../aws-elasticloadbalancing';\nimport * as elbv2 from '../../../aws-elasticloadbalancingv2';\nimport * as iam from '../../../aws-iam';\nimport * as cloudmap from '../../../aws-servicediscovery';\nimport { Annotations, Duration, IResolvable, IResource, Lazy, Resource, Stack } from '../../../core';\nimport { Construct } from 'constructs';\nimport { LoadBalancerTargetOptions, NetworkMode, TaskDefinition } from '../base/task-definition';\nimport { ICluster, CapacityProviderStrategy, ExecuteCommandLogging } from '../cluster';\nimport { ContainerDefinition, Protocol } from '../container-definition';\nimport { CfnService } from '../ecs.generated';\nimport { ScalableTaskCount } from './scalable-task-count';\n\n                                       \nexport interface IService extends IResource {\n                                                                                    \n  readonly serviceArn: string;\n\n                                                              \n  readonly serviceName: string;\n}\n\n                                                            \nexport interface DeploymentController {\n                                                                                                       \n  readonly type?: DeploymentControllerType;\n}\n\n                                                                \nexport interface DeploymentCircuitBreaker {\n                                                                                     \n  readonly rollback?: boolean;\n\n}\n\nexport interface EcsTarget {\n                                           \n  readonly containerName: string;\n\n                                                                                                                                                                                      \n  readonly containerPort?: number;\n\n                                                                                                                                               \n  readonly protocol?: Protocol;\n\n                                                     \n  readonly newTargetGroupId: string;\n\n                                                                                 \n  readonly listener: ListenerConfig;\n}\n\n                                                  \nexport interface IEcsLoadBalancerTarget extends elbv2.IApplicationLoadBalancerTarget, elbv2.INetworkLoadBalancerTarget, elb.ILoadBalancerTarget {\n}\n\n                                                                            \nexport interface BaseServiceOptions {\n                                                                \n  readonly cluster: ICluster;\n\n                                                                                                                                                                                                                                                \n  readonly desiredCount?: number;\n\n                                                                                             \n  readonly serviceName?: string;\n\n                                                                                                                                                                                                                                  \n  readonly maxHealthyPercent?: number;\n\n                                                                                                                                                                                                                                                  \n  readonly minHealthyPercent?: number;\n\n                                                                                                                                                                                                                                                                                                       \n  readonly healthCheckGracePeriod?: Duration;\n\n                                                                                                                                                                 \n  readonly cloudMapOptions?: CloudMapOptions;\n\n                                                                                                                                                                                                                                                                                                 \n  readonly propagateTags?: PropagatedTagSource;\n\n                                                                                                                                                                                                                                                                                                                 \n  readonly propagateTaskTagsFrom?: PropagatedTagSource;\n\n                                                                                                                                                                                                                                                                                   \n  readonly enableECSManagedTags?: boolean;\n\n                                                                                                                                                                                                                                                                        \n  readonly deploymentController?: DeploymentController;\n\n                                                                                                                                                                         \n  readonly circuitBreaker?: DeploymentCircuitBreaker;\n\n                                                                                                                    \n  readonly capacityProviderStrategies?: CapacityProviderStrategy[];\n\n                                                                                                          \n  readonly enableExecuteCommand?: boolean;\n}\n\n                                                                                                                               \nexport interface BaseServiceProps extends BaseServiceOptions {\n                                                                                                                                                                                                                                                                                                                                                                                                                \n  readonly launchType: LaunchType;\n}\n\n                                                                        \nexport abstract class ListenerConfig {\n                                                                         \n  public static applicationListener(listener: elbv2.ApplicationListener, props?: elbv2.AddApplicationTargetsProps): ListenerConfig {\n    return new ApplicationListenerConfig(listener, props);\n  }\n\n                                                                         \n  public static networkListener(listener: elbv2.NetworkListener, props?: elbv2.AddNetworkTargetsProps): ListenerConfig {\n    return new NetworkListenerConfig(listener, props);\n  }\n\n                                                              \n  public abstract addTargets(id: string, target: LoadBalancerTargetOptions, service: BaseService): void;\n}\n\n/**\n * Class for configuring application load balancer listener when registering targets.\n */\nclass ApplicationListenerConfig extends ListenerConfig {\n  constructor(private readonly listener: elbv2.ApplicationListener, private readonly props?: elbv2.AddApplicationTargetsProps) {\n    super();\n  }\n\n  /**\n   * Create and attach a target group to listener.\n   */\n  public addTargets(id: string, target: LoadBalancerTargetOptions, service: BaseService) {\n    const props = this.props || {};\n    const protocol = props.protocol;\n    const port = props.port ?? (protocol === elbv2.ApplicationProtocol.HTTPS ? 443 : 80);\n    this.listener.addTargets(id, {\n      ... props,\n      targets: [\n        service.loadBalancerTarget({\n          ...target,\n        }),\n      ],\n      port,\n    });\n  }\n}\n\n/**\n * Class for configuring network load balancer listener when registering targets.\n */\nclass NetworkListenerConfig extends ListenerConfig {\n  constructor(private readonly listener: elbv2.NetworkListener, private readonly props?: elbv2.AddNetworkTargetsProps) {\n    super();\n  }\n\n  /**\n   * Create and attach a target group to listener.\n   */\n  public addTargets(id: string, target: LoadBalancerTargetOptions, service: BaseService) {\n    const port = this.props?.port ?? 80;\n    this.listener.addTargets(id, {\n      ... this.props,\n      targets: [\n        service.loadBalancerTarget({\n          ...target,\n        }),\n      ],\n      port,\n    });\n  }\n}\n\n                                         \nexport interface IBaseService extends IService {\n                                                    \n  readonly cluster: ICluster;\n}\n\n                                                                     \nexport abstract class BaseService extends Resource\n  implements IBaseService, elbv2.IApplicationLoadBalancerTarget, elbv2.INetworkLoadBalancerTarget, elb.ILoadBalancerTarget {\n\n                                                                                              \n  public readonly connections: ec2.Connections = new ec2.Connections();\n\n                                                               \n  public readonly serviceArn: string;\n\n                                                              \n  public readonly serviceName: string;\n\n                                                                     \n  public readonly taskDefinition: TaskDefinition;\n\n                                                    \n  public readonly cluster: ICluster;\n\n                                                          \n  protected cloudmapService?: cloudmap.Service;\n\n                                                                                                                                                                                                                                       \n  protected loadBalancers = new Array<CfnService.LoadBalancerProperty>();\n\n                                                                                                                                                                                                                                       \n  protected networkConfiguration?: CfnService.NetworkConfigurationProperty;\n\n                                                                                                                                             \n  protected serviceRegistries = new Array<CfnService.ServiceRegistryProperty>();\n\n  private readonly resource: CfnService;\n  private scalableTaskCount?: ScalableTaskCount;\n\n                                                                    \n  constructor(\n    scope: Construct,\n    id: string,\n    props: BaseServiceProps,\n    additionalProps: any,\n    taskDefinition: TaskDefinition) {\n    super(scope, id, {\n      physicalName: props.serviceName,\n    });\n\n    if (props.propagateTags && props.propagateTaskTagsFrom) {\n      throw new Error('You can only specify either propagateTags or propagateTaskTagsFrom. Alternatively, you can leave both blank');\n    }\n\n    this.taskDefinition = taskDefinition;\n\n    // launchType will set to undefined if using external DeploymentController or capacityProviderStrategies\n    const launchType = props.deploymentController?.type === DeploymentControllerType.EXTERNAL ||\n      props.capacityProviderStrategies !== undefined ?\n      undefined : props.launchType;\n\n    const propagateTagsFromSource = props.propagateTaskTagsFrom ?? props.propagateTags ?? PropagatedTagSource.NONE;\n\n    this.resource = new CfnService(this, 'Service', {\n      desiredCount: props.desiredCount,\n      serviceName: this.physicalName,\n      loadBalancers: Lazy.any({ produce: () => this.loadBalancers }, { omitEmptyArray: true }),\n      deploymentConfiguration: {\n        maximumPercent: props.maxHealthyPercent || 200,\n        minimumHealthyPercent: props.minHealthyPercent === undefined ? 50 : props.minHealthyPercent,\n        deploymentCircuitBreaker: props.circuitBreaker ? {\n          enable: true,\n          rollback: props.circuitBreaker.rollback ?? false,\n        } : undefined,\n      },\n      propagateTags: propagateTagsFromSource === PropagatedTagSource.NONE ? undefined : props.propagateTags,\n      enableEcsManagedTags: props.enableECSManagedTags ?? false,\n      deploymentController: props.circuitBreaker ? {\n        type: DeploymentControllerType.ECS,\n      } : props.deploymentController,\n      launchType: launchType,\n      enableExecuteCommand: props.enableExecuteCommand,\n      capacityProviderStrategy: props.capacityProviderStrategies,\n      healthCheckGracePeriodSeconds: this.evaluateHealthGracePeriod(props.healthCheckGracePeriod),\n      /* role: never specified, supplanted by Service Linked Role */\n      networkConfiguration: Lazy.any({ produce: () => this.networkConfiguration }, { omitEmptyArray: true }),\n      serviceRegistries: Lazy.any({ produce: () => this.serviceRegistries }, { omitEmptyArray: true }),\n      ...additionalProps,\n    });\n\n    if (props.deploymentController?.type === DeploymentControllerType.EXTERNAL) {\n      Annotations.of(this).addWarning('taskDefinition and launchType are blanked out when using external deployment controller.');\n    }\n\n    this.serviceArn = this.getResourceArnAttribute(this.resource.ref, {\n      service: 'ecs',\n      resource: 'service',\n      resourceName: `${props.cluster.clusterName}/${this.physicalName}`,\n    });\n    this.serviceName = this.getResourceNameAttribute(this.resource.attrName);\n\n    this.cluster = props.cluster;\n\n    if (props.cloudMapOptions) {\n      this.enableCloudMap(props.cloudMapOptions);\n    }\n\n    if (props.enableExecuteCommand) {\n      this.enableExecuteCommand();\n\n      const logging = this.cluster.executeCommandConfiguration?.logging ?? ExecuteCommandLogging.DEFAULT;\n\n      if (this.cluster.executeCommandConfiguration?.kmsKey) {\n        this.enableExecuteCommandEncryption(logging);\n      }\n      if (logging !== ExecuteCommandLogging.NONE) {\n        this.executeCommandLogConfiguration();\n      }\n    }\n    this.node.defaultChild = this.resource;\n  }\n\n                                                                       \n  public get cloudMapService(): cloudmap.IService | undefined {\n    return this.cloudmapService;\n  }\n\n  private executeCommandLogConfiguration() {\n    const logConfiguration = this.cluster.executeCommandConfiguration?.logConfiguration;\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'logs:DescribeLogGroups',\n      ],\n      resources: ['*'],\n    }));\n\n    const logGroupArn = logConfiguration?.cloudWatchLogGroup ? `arn:aws:logs:${this.stack.region}:${this.stack.account}:log-group:${logConfiguration.cloudWatchLogGroup.logGroupName}:*` : '*';\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'logs:CreateLogStream',\n        'logs:DescribeLogStreams',\n        'logs:PutLogEvents',\n      ],\n      resources: [logGroupArn],\n    }));\n\n    if (logConfiguration?.s3Bucket?.bucketName) {\n      this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n        actions: [\n          's3:GetBucketLocation',\n        ],\n        resources: ['*'],\n      }));\n      this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n        actions: [\n          's3:PutObject',\n        ],\n        resources: [`arn:aws:s3:::${logConfiguration.s3Bucket.bucketName}/*`],\n      }));\n      if (logConfiguration.s3EncryptionEnabled) {\n        this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n          actions: [\n            's3:GetEncryptionConfiguration',\n          ],\n          resources: [`arn:aws:s3:::${logConfiguration.s3Bucket.bucketName}`],\n        }));\n      }\n    }\n  }\n\n  private enableExecuteCommandEncryption(logging: ExecuteCommandLogging) {\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'kms:Decrypt',\n        'kms:GenerateDataKey',\n      ],\n      resources: [`${this.cluster.executeCommandConfiguration?.kmsKey?.keyArn}`],\n    }));\n\n    this.cluster.executeCommandConfiguration?.kmsKey?.addToResourcePolicy(new iam.PolicyStatement({\n      actions: [\n        'kms:*',\n      ],\n      resources: ['*'],\n      principals: [new iam.ArnPrincipal(`arn:aws:iam::${this.stack.account}:root`)],\n    }));\n\n    if (logging === ExecuteCommandLogging.DEFAULT || this.cluster.executeCommandConfiguration?.logConfiguration?.cloudWatchEncryptionEnabled) {\n      this.cluster.executeCommandConfiguration?.kmsKey?.addToResourcePolicy(new iam.PolicyStatement({\n        actions: [\n          'kms:Encrypt*',\n          'kms:Decrypt*',\n          'kms:ReEncrypt*',\n          'kms:GenerateDataKey*',\n          'kms:Describe*',\n        ],\n        resources: ['*'],\n        principals: [new iam.ServicePrincipal(`logs.${this.stack.region}.amazonaws.com`)],\n        conditions: {\n          ArnLike: { 'kms:EncryptionContext:aws:logs:arn': `arn:aws:logs:${this.stack.region}:${this.stack.account}:*` },\n        },\n      }));\n    }\n  }\n\n                                                                                                                                                                                                                              \n  public attachToApplicationTargetGroup(targetGroup: elbv2.IApplicationTargetGroup): elbv2.LoadBalancerTargetProps {\n    return this.defaultLoadBalancerTarget.attachToApplicationTargetGroup(targetGroup);\n  }\n\n                                                                                                                                                        \n  public attachToClassicLB(loadBalancer: elb.LoadBalancer): void {\n    return this.defaultLoadBalancerTarget.attachToClassicLB(loadBalancer);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public loadBalancerTarget(options: LoadBalancerTargetOptions): IEcsLoadBalancerTarget {\n    const self = this;\n    const target = this.taskDefinition._validateTarget(options);\n    const connections = self.connections;\n    return {\n      attachToApplicationTargetGroup(targetGroup: elbv2.ApplicationTargetGroup): elbv2.LoadBalancerTargetProps {\n        targetGroup.registerConnectable(self, self.taskDefinition._portRangeFromPortMapping(target.portMapping));\n        return self.attachToELBv2(targetGroup, target.containerName, target.portMapping.containerPort);\n      },\n      attachToNetworkTargetGroup(targetGroup: elbv2.NetworkTargetGroup): elbv2.LoadBalancerTargetProps {\n        return self.attachToELBv2(targetGroup, target.containerName, target.portMapping.containerPort);\n      },\n      connections,\n      attachToClassicLB(loadBalancer: elb.LoadBalancer): void {\n        return self.attachToELB(loadBalancer, target.containerName, target.portMapping.containerPort);\n      },\n    };\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  public registerLoadBalancerTargets(...targets: EcsTarget[]) {\n    for (const target of targets) {\n      target.listener.addTargets(target.newTargetGroupId, {\n        containerName: target.containerName,\n        containerPort: target.containerPort,\n        protocol: target.protocol,\n      }, this);\n    }\n  }\n\n                                                                                                                                                                                                                         \n  public attachToNetworkTargetGroup(targetGroup: elbv2.INetworkTargetGroup): elbv2.LoadBalancerTargetProps {\n    return this.defaultLoadBalancerTarget.attachToNetworkTargetGroup(targetGroup);\n  }\n\n                                                                                                      \n  public autoScaleTaskCount(props: appscaling.EnableScalingProps) {\n    if (this.scalableTaskCount) {\n      throw new Error('AutoScaling of task count already enabled for this service');\n    }\n\n    return this.scalableTaskCount = new ScalableTaskCount(this, 'TaskCount', {\n      serviceNamespace: appscaling.ServiceNamespace.ECS,\n      resourceId: `service/${this.cluster.clusterName}/${this.serviceName}`,\n      dimension: 'ecs:service:DesiredCount',\n      role: this.makeAutoScalingRole(),\n      ...props,\n    });\n  }\n\n                                                                                                                  \n  public enableCloudMap(options: CloudMapOptions): cloudmap.Service {\n    const sdNamespace = options.cloudMapNamespace ?? this.cluster.defaultCloudMapNamespace;\n    if (sdNamespace === undefined) {\n      throw new Error('Cannot enable service discovery if a Cloudmap Namespace has not been created in the cluster.');\n    }\n\n    // Determine DNS type based on network mode\n    const networkMode = this.taskDefinition.networkMode;\n    if (networkMode === NetworkMode.NONE) {\n      throw new Error('Cannot use a service discovery if NetworkMode is None. Use Bridge, Host or AwsVpc instead.');\n    }\n\n    // Bridge or host network mode requires SRV records\n    let dnsRecordType = options.dnsRecordType;\n\n    if (networkMode === NetworkMode.BRIDGE || networkMode === NetworkMode.HOST) {\n      if (dnsRecordType === undefined) {\n        dnsRecordType = cloudmap.DnsRecordType.SRV;\n      }\n      if (dnsRecordType !== cloudmap.DnsRecordType.SRV) {\n        throw new Error('SRV records must be used when network mode is Bridge or Host.');\n      }\n    }\n\n    // Default DNS record type for AwsVpc network mode is A Records\n    if (networkMode === NetworkMode.AWS_VPC) {\n      if (dnsRecordType === undefined) {\n        dnsRecordType = cloudmap.DnsRecordType.A;\n      }\n    }\n\n    const { containerName, containerPort } = determineContainerNameAndPort({\n      taskDefinition: this.taskDefinition,\n      dnsRecordType: dnsRecordType!,\n      container: options.container,\n      containerPort: options.containerPort,\n    });\n\n    const cloudmapService = new cloudmap.Service(this, 'CloudmapService', {\n      namespace: sdNamespace,\n      name: options.name,\n      dnsRecordType: dnsRecordType!,\n      customHealthCheck: { failureThreshold: options.failureThreshold || 1 },\n      dnsTtl: options.dnsTtl,\n    });\n\n    const serviceArn = cloudmapService.serviceArn;\n\n    // add Cloudmap service to the ECS Service's serviceRegistry\n    this.addServiceRegistry({\n      arn: serviceArn,\n      containerName,\n      containerPort,\n    });\n\n    this.cloudmapService = cloudmapService;\n\n    return cloudmapService;\n  }\n\n                                                                \n  public associateCloudMapService(options: AssociateCloudMapServiceOptions): void {\n    const service = options.service;\n\n    const { containerName, containerPort } = determineContainerNameAndPort({\n      taskDefinition: this.taskDefinition,\n      dnsRecordType: service.dnsRecordType,\n      container: options.container,\n      containerPort: options.containerPort,\n    });\n\n    // add Cloudmap service to the ECS Service's serviceRegistry\n    this.addServiceRegistry({\n      arn: service.serviceArn,\n      containerName,\n      containerPort,\n    });\n  }\n\n                                                                                           \n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/ECS',\n      metricName,\n      dimensionsMap: { ClusterName: this.cluster.clusterName, ServiceName: this.serviceName },\n      ...props,\n    }).attachTo(this);\n  }\n\n                                                                                                                                           \n  public metricMemoryUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metric('MemoryUtilization', props);\n  }\n\n                                                                                                                                        \n  public metricCpuUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metric('CPUUtilization', props);\n  }\n\n                                                                                                                                                  \n  // eslint-disable-next-line max-len\n  protected configureAwsVpcNetworking(vpc: ec2.IVpc, assignPublicIp?: boolean, vpcSubnets?: ec2.SubnetSelection, securityGroup?: ec2.ISecurityGroup) {\n    if (vpcSubnets === undefined) {\n      vpcSubnets = assignPublicIp ? { subnetType: ec2.SubnetType.PUBLIC } : {};\n    }\n    if (securityGroup === undefined) {\n      securityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', { vpc });\n    }\n    this.connections.addSecurityGroup(securityGroup);\n\n    this.networkConfiguration = {\n      awsvpcConfiguration: {\n        assignPublicIp: assignPublicIp ? 'ENABLED' : 'DISABLED',\n        subnets: vpc.selectSubnets(vpcSubnets).subnetIds,\n        securityGroups: Lazy.list({ produce: () => [securityGroup!.securityGroupId] }),\n      },\n    };\n  }\n\n                                                                        \n  // eslint-disable-next-line max-len\n  protected configureAwsVpcNetworkingWithSecurityGroups(vpc: ec2.IVpc, assignPublicIp?: boolean, vpcSubnets?: ec2.SubnetSelection, securityGroups?: ec2.ISecurityGroup[]) {\n    if (vpcSubnets === undefined) {\n      vpcSubnets = assignPublicIp ? { subnetType: ec2.SubnetType.PUBLIC } : {};\n    }\n    if (securityGroups === undefined || securityGroups.length === 0) {\n      securityGroups = [new ec2.SecurityGroup(this, 'SecurityGroup', { vpc })];\n    }\n\n    securityGroups.forEach((sg) => { this.connections.addSecurityGroup(sg); }, this);\n\n    this.networkConfiguration = {\n      awsvpcConfiguration: {\n        assignPublicIp: assignPublicIp ? 'ENABLED' : 'DISABLED',\n        subnets: vpc.selectSubnets(vpcSubnets).subnetIds,\n        securityGroups: securityGroups.map((sg) => sg.securityGroupId),\n      },\n    };\n  }\n\n  private renderServiceRegistry(registry: ServiceRegistry): CfnService.ServiceRegistryProperty {\n    return {\n      registryArn: registry.arn,\n      containerName: registry.containerName,\n      containerPort: registry.containerPort,\n    };\n  }\n\n  /**\n   * Shared logic for attaching to an ELB\n   */\n  private attachToELB(loadBalancer: elb.LoadBalancer, containerName: string, containerPort: number): void {\n    if (this.taskDefinition.networkMode === NetworkMode.AWS_VPC) {\n      throw new Error('Cannot use a Classic Load Balancer if NetworkMode is AwsVpc. Use Host or Bridge instead.');\n    }\n    if (this.taskDefinition.networkMode === NetworkMode.NONE) {\n      throw new Error('Cannot use a Classic Load Balancer if NetworkMode is None. Use Host or Bridge instead.');\n    }\n\n    this.loadBalancers.push({\n      loadBalancerName: loadBalancer.loadBalancerName,\n      containerName,\n      containerPort,\n    });\n  }\n\n  /**\n   * Shared logic for attaching to an ELBv2\n   */\n  private attachToELBv2(targetGroup: elbv2.ITargetGroup, containerName: string, containerPort: number): elbv2.LoadBalancerTargetProps {\n    if (this.taskDefinition.networkMode === NetworkMode.NONE) {\n      throw new Error('Cannot use a load balancer if NetworkMode is None. Use Bridge, Host or AwsVpc instead.');\n    }\n\n    this.loadBalancers.push({\n      targetGroupArn: targetGroup.targetGroupArn,\n      containerName,\n      containerPort,\n    });\n\n    // Service creation can only happen after the load balancer has\n    // been associated with our target group(s), so add ordering dependency.\n    this.resource.node.addDependency(targetGroup.loadBalancerAttached);\n\n    const targetType = this.taskDefinition.networkMode === NetworkMode.AWS_VPC ? elbv2.TargetType.IP : elbv2.TargetType.INSTANCE;\n    return { targetType };\n  }\n\n  private get defaultLoadBalancerTarget() {\n    return this.loadBalancerTarget({\n      containerName: this.taskDefinition.defaultContainer!.containerName,\n    });\n  }\n\n  /**\n   * Generate the role that will be used for autoscaling this service\n   */\n  private makeAutoScalingRole(): iam.IRole {\n    // Use a Service Linked Role.\n    return iam.Role.fromRoleArn(this, 'ScalingRole', Stack.of(this).formatArn({\n      region: '',\n      service: 'iam',\n      resource: 'role/aws-service-role/ecs.application-autoscaling.amazonaws.com',\n      resourceName: 'AWSServiceRoleForApplicationAutoScaling_ECSService',\n    }));\n  }\n\n  /**\n   * Associate Service Discovery (Cloud Map) service\n   */\n  private addServiceRegistry(registry: ServiceRegistry) {\n    if (this.serviceRegistries.length >= 1) {\n      throw new Error('Cannot associate with the given service discovery registry. ECS supports at most one service registry per service.');\n    }\n\n    const sr = this.renderServiceRegistry(registry);\n    this.serviceRegistries.push(sr);\n  }\n\n  /**\n   *  Return the default grace period when load balancers are configured and\n   *  healthCheckGracePeriod is not already set\n   */\n  private evaluateHealthGracePeriod(providedHealthCheckGracePeriod?: Duration): IResolvable {\n    return Lazy.any({\n      produce: () => providedHealthCheckGracePeriod?.toSeconds() ?? (this.loadBalancers.length > 0 ? 60 : undefined),\n    });\n  }\n\n  private enableExecuteCommand() {\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'ssmmessages:CreateControlChannel',\n        'ssmmessages:CreateDataChannel',\n        'ssmmessages:OpenControlChannel',\n        'ssmmessages:OpenDataChannel',\n      ],\n      resources: ['*'],\n    }));\n  }\n}\n\n                                                                           \nexport interface CloudMapOptions {\n                                                                                                                                 \n  readonly name?: string,\n\n                                                                                                                                                                                    \n  readonly cloudMapNamespace?: cloudmap.INamespace;\n\n                                                                                                                                                                                                                              \n  readonly dnsRecordType?: cloudmap.DnsRecordType.A | cloudmap.DnsRecordType.SRV,\n\n                                                                                                                                             \n  readonly dnsTtl?: Duration;\n\n                                                                                                                                                                                                                                                                       \n  readonly failureThreshold?: number;\n\n                                                                                                                    \n  readonly container?: ContainerDefinition;\n\n                                                                                                                                   \n  readonly containerPort?: number;\n}\n\n                                                    \nexport interface AssociateCloudMapServiceOptions {\n                                                       \n  readonly service: cloudmap.IService;\n\n                                                                                                                    \n  readonly container?: ContainerDefinition;\n\n                                                                                                                                   \n  readonly containerPort?: number;\n}\n\n/**\n * Service Registry for ECS service\n */\ninterface ServiceRegistry {\n  /**\n   * Arn of the Cloud Map Service that will register a Cloud Map Instance for your ECS Service\n   */\n  readonly arn: string;\n\n  /**\n   * The container name value, already specified in the task definition, to be used for your service discovery service.\n   * If the task definition that your service task specifies uses the bridge or host network mode,\n   * you must specify a containerName and containerPort combination from the task definition.\n   * If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is\n   * used, you must specify either a containerName and containerPort combination or a port value, but not both.\n   */\n  readonly containerName?: string;\n\n  /**\n   * The container port value, already specified in the task definition, to be used for your service discovery service.\n   * If the task definition that your service task specifies uses the bridge or host network mode,\n   * you must specify a containerName and containerPort combination from the task definition.\n   * If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is\n   * used, you must specify either a containerName and containerPort combination or a port value, but not both.\n   */\n  readonly containerPort?: number;\n}\n\n                                            \nexport enum LaunchType {\n                                                                       \n  EC2 = 'EC2',\n\n                                                                           \n  FARGATE = 'FARGATE',\n\n                                                                            \n  EXTERNAL = 'EXTERNAL'\n}\n\n                                                                 \nexport enum DeploymentControllerType {\n                                                                                                                                                       \n  ECS = 'ECS',\n\n                                                                                                                            \n  CODE_DEPLOY = 'CODE_DEPLOY',\n\n                                                                                                                 \n  EXTERNAL = 'EXTERNAL'\n}\n\n                                                                \nexport enum PropagatedTagSource {\n                                            \n  SERVICE = 'SERVICE',\n\n                                                    \n  TASK_DEFINITION = 'TASK_DEFINITION',\n\n                                 \n  NONE = 'NONE'\n}\n\n/**\n * Options for `determineContainerNameAndPort`\n */\ninterface DetermineContainerNameAndPortOptions {\n  dnsRecordType: cloudmap.DnsRecordType;\n  taskDefinition: TaskDefinition;\n  container?: ContainerDefinition;\n  containerPort?: number;\n}\n\n/**\n * Determine the name of the container and port to target for the service registry.\n */\nfunction determineContainerNameAndPort(options: DetermineContainerNameAndPortOptions) {\n  // If the record type is SRV, then provide the containerName and containerPort to target.\n  // We use the name of the default container and the default port of the default container\n  // unless the user specifies otherwise.\n  if (options.dnsRecordType === cloudmap.DnsRecordType.SRV) {\n    // Ensure the user-provided container is from the right task definition.\n    if (options.container && options.container.taskDefinition != options.taskDefinition) {\n      throw new Error('Cannot add discovery for a container from another task definition');\n    }\n\n    const container = options.container ?? options.taskDefinition.defaultContainer!;\n\n    // Ensure that any port given by the user is mapped.\n    if (options.containerPort && !container.portMappings.some(mapping => mapping.containerPort === options.containerPort)) {\n      throw new Error('Cannot add discovery for a container port that has not been mapped');\n    }\n\n    return {\n      containerName: container.containerName,\n      containerPort: options.containerPort ?? options.taskDefinition.defaultContainer!.containerPort,\n    };\n  }\n\n  return {};\n}\n"],
  "mappings": "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",
  "names": []
}
