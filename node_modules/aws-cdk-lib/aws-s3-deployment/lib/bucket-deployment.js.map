{
  "version": 3,
  "sources": ["bucket-deployment.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport * as cloudfront from '../../aws-cloudfront';\nimport * as ec2 from '../../aws-ec2';\nimport * as efs from '../../aws-efs';\nimport * as iam from '../../aws-iam';\nimport * as lambda from '../../aws-lambda';\nimport * as logs from '../../aws-logs';\nimport * as s3 from '../../aws-s3';\nimport * as cdk from '../../core';\nimport { AwsCliLayer } from '../../lambda-layer-awscli';\nimport { kebab as toKebabCase } from 'case';\nimport { Construct } from 'constructs';\nimport { ISource, SourceConfig } from './source';\n\n// tag key has a limit of 128 characters\nconst CUSTOM_RESOURCE_OWNER_TAG = 'aws-cdk:cr-owned';\n\n                                             \nexport interface BucketDeploymentProps {\n                                                                              \n  readonly sources: ISource[];\n\n                                                                       \n  readonly destinationBucket: s3.IBucket;\n\n                                                                                                                                                          \n  readonly destinationKeyPrefix?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  readonly exclude?: string[]\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly include?: string[]\n\n                                                                                                                                                                                                                                                                          \n  readonly prune?: boolean\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n  readonly retainOnDelete?: boolean;\n\n                                                                                                                                                                                                                                                             \n  readonly distribution?: cloudfront.IDistribution;\n\n                                                                                                                                                                         \n  readonly distributionPaths?: string[];\n\n\n                                                                                                                                                     \n  readonly logRetention?: logs.RetentionDays;\n\n                                                                                                                                                                                                                                                                                               \n  readonly memoryLimit?: number;\n\n                                                                                                                                                                                                                                                                \n  readonly useEfs?: boolean\n\n                                                                                                                  \n  readonly role?: iam.IRole;\n\n                                                                                                                                                                                                                          \n  readonly metadata?: UserDefinedObjectMetadata;\n\n                                                                                                                                                                                                                    \n  readonly cacheControl?: CacheControl[];\n                                                                                                                                                                                                                        \n  readonly contentDisposition?: string;\n                                                                                                                                                                                                                       \n  readonly contentEncoding?: string;\n                                                                                                                                                                                                                       \n  readonly contentLanguage?: string;\n                                                                                                                                                                                                                   \n  readonly contentType?: string;\n                                                                                                                                                                                                                                                      \n  readonly expires?: cdk.Expiration;\n                                                                                                                                                                                                                                                              \n  readonly serverSideEncryption?: ServerSideEncryption;\n                                                                                                                                                                                                                                                               \n  readonly storageClass?: StorageClass;\n                                                                                                                                                                                                                                                     \n  readonly websiteRedirectLocation?: string;\n                                                                                                                                                                                                                                                  \n  readonly serverSideEncryptionAwsKmsKeyId?: string;\n                                                                                                                                                                                                                                                                                                                                                                                                                  \n  readonly serverSideEncryptionCustomerAlgorithm?: string;\n                                                                                                                                                                                                                    \n  readonly accessControl?: s3.BucketAccessControl;\n\n                                                                                                                                             \n  readonly vpc?: ec2.IVpc;\n\n                                                                                                                                                                             \n  readonly vpcSubnets?: ec2.SubnetSelection;\n}\n\n                                                                                                                                \nexport class BucketDeployment extends Construct {\n  constructor(scope: Construct, id: string, props: BucketDeploymentProps) {\n    super(scope, id);\n\n    if (props.distributionPaths) {\n      if (!props.distribution) {\n        throw new Error('Distribution must be specified if distribution paths are specified');\n      }\n      if (!cdk.Token.isUnresolved(props.distributionPaths)) {\n        if (!props.distributionPaths.every(distributionPath => cdk.Token.isUnresolved(distributionPath) || distributionPath.startsWith('/'))) {\n          throw new Error('Distribution paths must start with \"/\"');\n        }\n      }\n    }\n\n    if (props.useEfs && !props.vpc) {\n      throw new Error('Vpc must be specified if useEfs is set');\n    }\n\n    const accessPointPath = '/lambda';\n    let accessPoint;\n    if (props.useEfs && props.vpc) {\n      const accessMode = '0777';\n      const fileSystem = this.getOrCreateEfsFileSystem(scope, {\n        vpc: props.vpc,\n        removalPolicy: cdk.RemovalPolicy.DESTROY,\n      });\n      accessPoint = fileSystem.addAccessPoint('AccessPoint', {\n        path: accessPointPath,\n        createAcl: {\n          ownerUid: '1001',\n          ownerGid: '1001',\n          permissions: accessMode,\n        },\n        posixUser: {\n          uid: '1001',\n          gid: '1001',\n        },\n      });\n      accessPoint.node.addDependency(fileSystem.mountTargetsAvailable);\n    }\n\n    // Making VPC dependent on BucketDeployment so that CFN stack deletion is smooth.\n    // Refer comments on https://github.com/aws/aws-cdk/pull/15220 for more details.\n    if (props.vpc) {\n      this.node.addDependency(props.vpc);\n    }\n\n    const mountPath = `/mnt${accessPointPath}`;\n    const handler = new lambda.SingletonFunction(this, 'CustomResourceHandler', {\n      uuid: this.renderSingletonUuid(props.memoryLimit, props.vpc),\n      code: lambda.Code.fromAsset(path.join(__dirname, 'lambda')),\n      layers: [new AwsCliLayer(this, 'AwsCliLayer')],\n      runtime: lambda.Runtime.PYTHON_3_7,\n      environment: props.useEfs ? {\n        MOUNT_PATH: mountPath,\n      } : undefined,\n      handler: 'index.handler',\n      lambdaPurpose: 'Custom::CDKBucketDeployment',\n      timeout: cdk.Duration.minutes(15),\n      role: props.role,\n      memorySize: props.memoryLimit,\n      vpc: props.vpc,\n      vpcSubnets: props.vpcSubnets,\n      filesystem: accessPoint ? lambda.FileSystem.fromEfsAccessPoint(\n        accessPoint,\n        mountPath,\n      ) : undefined,\n      logRetention: props.logRetention,\n    });\n\n    const handlerRole = handler.role;\n    if (!handlerRole) { throw new Error('lambda.SingletonFunction should have created a Role'); }\n\n    const sources: SourceConfig[] = props.sources.map((source: ISource) => source.bind(this, { handlerRole }));\n\n    props.destinationBucket.grantReadWrite(handler);\n    if (props.distribution) {\n      handler.addToRolePolicy(new iam.PolicyStatement({\n        effect: iam.Effect.ALLOW,\n        actions: ['cloudfront:GetInvalidation', 'cloudfront:CreateInvalidation'],\n        resources: ['*'],\n      }));\n    }\n\n    const crUniqueId = `CustomResource${this.renderUniqueId(props.memoryLimit, props.vpc)}`;\n    const cr = new cdk.CustomResource(this, crUniqueId, {\n      serviceToken: handler.functionArn,\n      resourceType: 'Custom::CDKBucketDeployment',\n      properties: {\n        SourceBucketNames: sources.map(source => source.bucket.bucketName),\n        SourceObjectKeys: sources.map(source => source.zipObjectKey),\n        DestinationBucketName: props.destinationBucket.bucketName,\n        DestinationBucketKeyPrefix: props.destinationKeyPrefix,\n        RetainOnDelete: props.retainOnDelete,\n        Prune: props.prune ?? true,\n        Exclude: props.exclude,\n        Include: props.include,\n        UserMetadata: props.metadata ? mapUserMetadata(props.metadata) : undefined,\n        SystemMetadata: mapSystemMetadata(props),\n        DistributionId: props.distribution?.distributionId,\n        DistributionPaths: props.distributionPaths,\n      },\n    });\n\n    let prefix: string = props.destinationKeyPrefix ?\n      `:${props.destinationKeyPrefix}` :\n      '';\n    prefix += `:${cr.node.addr.substr(-8)}`;\n    const tagKey = CUSTOM_RESOURCE_OWNER_TAG + prefix;\n\n    // destinationKeyPrefix can be 104 characters before we hit\n    // the tag key limit of 128\n    // '/this/is/a/random/key/prefix/that/is/a/lot/of/characters/do/we/think/that/it/will/ever/be/this/long?????'\n    // better to throw an error here than wait for CloudFormation to fail\n    if (tagKey.length > 128) {\n      throw new Error('The BucketDeployment construct requires that the \"destinationKeyPrefix\" be <=104 characters');\n    }\n\n    /*\n     * This will add a tag to the deployment bucket in the format of\n     * `aws-cdk:cr-owned:{keyPrefix}:{uniqueHash}`\n     *\n     * For example:\n     * {\n     *   Key: 'aws-cdk:cr-owned:deploy/here/:240D17B3',\n     *   Value: 'true',\n     * }\n     *\n     * This will allow for scenarios where there is a single S3 Bucket that has multiple\n     * BucketDeployment resources deploying to it. Each bucket + keyPrefix can be \"owned\" by\n     * 1 or more BucketDeployment resources. Since there are some scenarios where multiple BucketDeployment\n     * resources can deploy to the same bucket and key prefix (e.g. using include/exclude) we\n     * also append part of the id to make the key unique.\n     *\n     * As long as a bucket + keyPrefix is \"owned\" by a BucketDeployment resource, another CR\n     * cannot delete data. There are a couple of scenarios where this comes into play.\n     *\n     * 1. If the LogicalResourceId of the CustomResource changes (e.g. the crUniqueId changes)\n     * CloudFormation will first issue a 'Create' to create the new CustomResource and will\n     * update the Tag on the bucket. CloudFormation will then issue a 'Delete' on the old CustomResource\n     * and since the new CR \"owns\" the Bucket+keyPrefix it will not delete the contents of the bucket\n     *\n     * 2. If the BucketDeployment resource is deleted _and_ it is the only CR for that bucket+keyPrefix\n     * then CloudFormation will first remove the tag from the bucket and then issue a \"Delete\" to the\n     * CR. Since there are no tags indicating that this bucket+keyPrefix is \"owned\" then it will delete\n     * the contents.\n     *\n     * 3. If the BucketDeployment resource is deleted _and_ it is *not* the only CR for that bucket:keyPrefix\n     * then CloudFormation will first remove the tag from the bucket and then issue a \"Delete\" to the CR.\n     * Since there are other CRs that also \"own\" that bucket+keyPrefix there will still be a tag on the bucket\n     * and the contents will not be removed.\n     *\n     * 4. If the BucketDeployment resource _and_ the S3 Bucket are both removed, then CloudFormation will first\n     * issue a \"Delete\" to the CR and since there is a tag on the bucket the contents will not be removed. If you\n     * want the contents of the bucket to be removed on bucket deletion, then `autoDeleteObjects` property should\n     * be set to true on the Bucket.\n     */\n    cdk.Tags.of(props.destinationBucket).add(tagKey, 'true');\n\n  }\n\n  private renderUniqueId(memoryLimit?: number, vpc?: ec2.IVpc) {\n    let uuid = '';\n\n    // if user specify a custom memory limit, define another singleton handler\n    // with this configuration. otherwise, it won't be possible to use multiple\n    // configurations since we have a singleton.\n    if (memoryLimit) {\n      if (cdk.Token.isUnresolved(memoryLimit)) {\n        throw new Error('Can\\'t use tokens when specifying \"memoryLimit\" since we use it to identify the singleton custom resource handler');\n      }\n\n      uuid += `-${memoryLimit.toString()}MiB`;\n    }\n\n    // if user specify to use VPC, define another singleton handler\n    // with this configuration. otherwise, it won't be possible to use multiple\n    // configurations since we have a singleton.\n    // A VPC is a must if EFS storage is used and that's why we are only using VPC in uuid.\n    if (vpc) {\n      uuid += `-${vpc.node.addr}`;\n    }\n\n    return uuid;\n  }\n\n  private renderSingletonUuid(memoryLimit?: number, vpc?: ec2.IVpc) {\n    let uuid = '8693BB64-9689-44B6-9AAF-B0CC9EB8756C';\n\n    uuid += this.renderUniqueId(memoryLimit, vpc);\n\n    return uuid;\n  }\n\n  /**\n   * Function to get/create a stack singleton instance of EFS FileSystem per vpc.\n   *\n   * @param scope Construct\n   * @param fileSystemProps EFS FileSystemProps\n   */\n  private getOrCreateEfsFileSystem(scope: Construct, fileSystemProps: efs.FileSystemProps): efs.FileSystem {\n    const stack = cdk.Stack.of(scope);\n    const uuid = `BucketDeploymentEFS-VPC-${fileSystemProps.vpc.node.addr}`;\n    return stack.node.tryFindChild(uuid) as efs.FileSystem ?? new efs.FileSystem(scope, uuid, fileSystemProps);\n  }\n}\n\n/**\n * Metadata\n */\n\nfunction mapUserMetadata(metadata: UserDefinedObjectMetadata) {\n  const mapKey = (key: string) => key.toLowerCase();\n\n  return Object.keys(metadata).reduce((o, key) => ({ ...o, [mapKey(key)]: metadata[key] }), {});\n}\n\nfunction mapSystemMetadata(metadata: BucketDeploymentProps) {\n  const res: { [key: string]: string } = {};\n\n  if (metadata.cacheControl) { res['cache-control'] = metadata.cacheControl.map(c => c.value).join(', '); }\n  if (metadata.expires) { res.expires = metadata.expires.date.toUTCString(); }\n  if (metadata.contentDisposition) { res['content-disposition'] = metadata.contentDisposition; }\n  if (metadata.contentEncoding) { res['content-encoding'] = metadata.contentEncoding; }\n  if (metadata.contentLanguage) { res['content-language'] = metadata.contentLanguage; }\n  if (metadata.contentType) { res['content-type'] = metadata.contentType; }\n  if (metadata.serverSideEncryption) { res.sse = metadata.serverSideEncryption; }\n  if (metadata.storageClass) { res['storage-class'] = metadata.storageClass; }\n  if (metadata.websiteRedirectLocation) { res['website-redirect'] = metadata.websiteRedirectLocation; }\n  if (metadata.serverSideEncryptionAwsKmsKeyId) { res['sse-kms-key-id'] = metadata.serverSideEncryptionAwsKmsKeyId; }\n  if (metadata.serverSideEncryptionCustomerAlgorithm) { res['sse-c-copy-source'] = metadata.serverSideEncryptionCustomerAlgorithm; }\n  if (metadata.accessControl) { res.acl = toKebabCase(metadata.accessControl.toString()); }\n\n  return Object.keys(res).length === 0 ? undefined : res;\n}\n\n                                                                                                                                                                         \nexport class CacheControl {\n\n                                        \n  public static mustRevalidate() { return new CacheControl('must-revalidate'); }\n\n                                 \n  public static noCache() { return new CacheControl('no-cache'); }\n\n                                     \n  public static noTransform() { return new CacheControl('no-transform'); }\n\n                               \n  public static setPublic() { return new CacheControl('public'); }\n\n                                \n  public static setPrivate() { return new CacheControl('private'); }\n\n                                         \n  public static proxyRevalidate() { return new CacheControl('proxy-revalidate'); }\n\n                                                      \n  public static maxAge(t: cdk.Duration) { return new CacheControl(`max-age=${t.toSeconds()}`); }\n\n                                                       \n  public static sMaxAge(t: cdk.Duration) { return new CacheControl(`s-maxage=${t.toSeconds()}`); }\n\n                                                                              \n  public static fromString(s: string) { return new CacheControl(s); }\n\n  private constructor(\n    /**\n     * The raw cache control setting.\n     */\n    public readonly value: any,\n  ) { }\n}\n\n                                                                                                                                                                                                                                                                                                    \nexport enum ServerSideEncryption {\n\n                         \n  AES_256 = 'AES256',\n\n                          \n  AWS_KMS = 'aws:kms'\n}\n\n                                                                                                                                            \nexport enum StorageClass {\n\n                           \n  STANDARD = 'STANDARD',\n\n                                     \n  REDUCED_REDUNDANCY = 'REDUCED_REDUNDANCY',\n\n                              \n  STANDARD_IA = 'STANDARD_IA',\n\n                             \n  ONEZONE_IA = 'ONEZONE_IA',\n\n                                      \n  INTELLIGENT_TIERING = 'INTELLIGENT_TIERING',\n\n                          \n  GLACIER = 'GLACIER',\n\n                               \n  DEEP_ARCHIVE = 'DEEP_ARCHIVE'\n}\n\n                                                                                                                                                                                                                                                    \nexport class Expires {\n                                                                             \n  public static atDate(d: Date) { return new Expires(d.toUTCString()); }\n\n                                                                                               \n  public static atTimestamp(t: number) { return Expires.atDate(new Date(t)); }\n\n                                                                                                                                       \n  public static after(t: cdk.Duration) { return Expires.atDate(new Date(Date.now() + t.toMilliseconds())); }\n\n                                                                  \n  public static fromString(s: string) { return new Expires(s); }\n\n  private constructor(\n    /**\n     * The raw expiration date expression.\n     */\n    public readonly value: any,\n  ) { }\n}\n\n                                        \nexport interface UserDefinedObjectMetadata {\n  /**\n   * Arbitrary metadata key-values\n   * The `x-amz-meta-` prefix will automatically be added to keys.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata\n   */\n  readonly [key: string]: string;\n}\n"],
  "mappings": "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",
  "names": []
}
