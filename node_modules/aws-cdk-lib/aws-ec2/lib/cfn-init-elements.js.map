{
  "version": 3,
  "sources": ["cfn-init-elements.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as iam from '../../aws-iam';\nimport * as s3 from '../../aws-s3';\nimport * as s3_assets from '../../aws-s3-assets';\nimport { Duration } from '../../core';\nimport { InitBindOptions, InitElementConfig, InitElementType, InitPlatform } from './private/cfn-init-internal';\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \nexport class InitServiceRestartHandle {\n  private readonly commands = new Array<string>();\n  private readonly files = new Array<string>();\n  private readonly sources = new Array<string>();\n  private readonly packages: Record<string, string[]> = {};\n\n  /**\n   * Add a command key to the restart set\n   * @internal\n   */\n  public _addCommand(key: string) {\n    return this.commands.push(key);\n  }\n\n  /**\n   * Add a file key to the restart set\n   * @internal\n   */\n  public _addFile(key: string) {\n    return this.files.push(key);\n  }\n\n  /**\n   * Add a source key to the restart set\n   * @internal\n   */\n  public _addSource(key: string) {\n    return this.sources.push(key);\n  }\n\n  /**\n   * Add a package key to the restart set\n   * @internal\n   */\n  public _addPackage(packageType: string, key: string) {\n    if (!this.packages[packageType]) {\n      this.packages[packageType] = [];\n    }\n    this.packages[packageType].push(key);\n  }\n\n  /**\n   * Render the restart handles for use in an InitService declaration\n   * @internal\n   */\n  public _renderRestartHandles(): any {\n    const nonEmpty = <A>(x: A[]) => x.length > 0 ? x : undefined;\n\n    return {\n      commands: nonEmpty(this.commands),\n      files: nonEmpty(this.files),\n      packages: Object.keys(this.packages).length > 0 ? this.packages : undefined,\n      sources: nonEmpty(this.sources),\n    };\n  }\n}\n\n                                                          \nexport abstract class InitElement {\n\n                                                                \n  public abstract readonly elementType: string;\n\n  /**\n   * Called when the Init config is being consumed. Renders the CloudFormation\n   * representation of this init element, and calculates any authentication\n   * properties needed, if any.\n   *\n   * @param options bind options for the element.\n   * @internal\n   */\n  public abstract _bind(options: InitBindOptions): InitElementConfig;\n\n}\n\n                                  \nexport interface InitCommandOptions {\n                                                                                                                                                                                         \n  readonly key?: string;\n\n                                                                                                                                                                                            \n  readonly env?: Record<string, string>;\n\n                                                                                         \n  readonly cwd?: string;\n\n                                                                                                                                                                                                   \n  readonly testCmd?: string;\n\n                                                                                \n  readonly ignoreErrors?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly waitAfterCompletion?: InitCommandWaitDuration;\n\n                                                                                                                        \n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n                                                                                                          \nexport abstract class InitCommandWaitDuration {\n                                                       \n  public static of(duration: Duration): InitCommandWaitDuration {\n    return new class extends InitCommandWaitDuration {\n      /** @internal */\n      public _render() { return duration.toSeconds(); }\n    }();\n  }\n\n                                      \n  public static none(): InitCommandWaitDuration {\n    return InitCommandWaitDuration.of(Duration.seconds(0));\n  }\n\n                                                           \n  public static forever(): InitCommandWaitDuration {\n    return new class extends InitCommandWaitDuration {\n      /** @internal */\n      public _render() { return 'forever'; }\n    }();\n  }\n\n  /**\n   * Render to a CloudFormation value.\n   * @internal\n   */\n  public abstract _render(): any;\n}\n\n                                             \nexport class InitCommand extends InitElement {\n                                                                                                                                                                                                                                \n  public static shellCommand(shellCommand: string, options: InitCommandOptions = {}): InitCommand {\n    return new InitCommand(shellCommand, options);\n  }\n\n                                                                                                                                               \n  public static argvCommand(argv: string[], options: InitCommandOptions = {}): InitCommand {\n    if (argv.length === 0) {\n      throw new Error('Cannot define argvCommand with an empty arguments');\n    }\n    return new InitCommand(argv, options);\n  }\n\n  public readonly elementType = InitElementType.COMMAND.toString();\n\n  private constructor(private readonly command: string[] | string, private readonly options: InitCommandOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    const commandKey = this.options.key || `${options.index}`.padStart(3, '0'); // 001, 005, etc.\n\n    if (options.platform !== InitPlatform.WINDOWS && this.options.waitAfterCompletion !== undefined) {\n      throw new Error(`Command '${this.command}': 'waitAfterCompletion' is only valid for Windows systems.`);\n    }\n\n    for (const handle of this.options.serviceRestartHandles ?? []) {\n      handle._addCommand(commandKey);\n    }\n\n    return {\n      config: {\n        [commandKey]: {\n          command: this.command,\n          env: this.options.env,\n          cwd: this.options.cwd,\n          test: this.options.testCmd,\n          ignoreErrors: this.options.ignoreErrors,\n          waitAfterCompletion: this.options.waitAfterCompletion?._render(),\n        },\n      },\n    };\n  }\n\n}\n\n                               \nexport interface InitFileOptions {\n                                                                                                                                   \n  readonly group?: string;\n\n                                                                                                                                  \n  readonly owner?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly mode?: string;\n\n                                                                                                                                                                                            \n  readonly base64Encoded?: boolean;\n\n                                                                                                                           \n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n                                                                     \nexport interface InitFileAssetOptions extends InitFileOptions, s3_assets.AssetOptions {\n}\n\n                                            \nexport abstract class InitFile extends InitElement {\n\n                                                         \n  public static fromString(fileName: string, content: string, options: InitFileOptions = {}): InitFile {\n    if (!content) {\n      throw new Error(`InitFile ${fileName}: cannot create empty file. Please supply at least one character of content.`);\n    }\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            content,\n            encoding: this.options.base64Encoded ? 'base64' : 'plain',\n          }),\n        };\n      }\n    }(fileName, options);\n  }\n\n                                                              \n  public static symlink(fileName: string, target: string, options: InitFileOptions = {}): InitFile {\n    const { mode, ...otherOptions } = options;\n    if (mode && mode.slice(0, 3) !== '120') {\n      throw new Error('File mode for symlinks must begin with 120XXX');\n    }\n    return InitFile.fromString(fileName, target, { mode: (mode || '120644'), ...otherOptions });\n  }\n\n                                                                                                                         \n  public static fromObject(fileName: string, obj: Record<string, any>, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            content: obj,\n          }),\n        };\n      }\n    }(fileName, options);\n  }\n\n                                                                                                                                                                                                                                                                              \n  public static fromFileInline(targetFileName: string, sourceFileName: string, options: InitFileOptions = {}): InitFile {\n    const encoding = options.base64Encoded ? 'base64' : 'utf8';\n    const fileContents = fs.readFileSync(sourceFileName).toString(encoding);\n    return InitFile.fromString(targetFileName, fileContents, options);\n  }\n\n                                                             \n  public static fromUrl(fileName: string, url: string, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: url,\n          }),\n        };\n      }\n    }(fileName, options);\n  }\n\n                                                                           \n  public static fromS3Object(fileName: string, bucket: s3.IBucket, key: string, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        bucket.grantRead(bindOptions.instanceRole, key);\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: bucket.urlForObject(key),\n          }),\n          authentication: standardS3Auth(bindOptions.instanceRole, bucket.bucketName),\n        };\n      }\n    }(fileName, options);\n  }\n\n                                                                                                                                           \n  public static fromAsset(targetFileName: string, path: string, options: InitFileAssetOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        const asset = new s3_assets.Asset(bindOptions.scope, `${targetFileName}Asset`, {\n          path,\n          ...options,\n        });\n        asset.grantRead(bindOptions.instanceRole);\n\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: asset.httpUrl,\n          }),\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetFileName, options);\n  }\n\n                                                                  \n  public static fromExistingAsset(targetFileName: string, asset: s3_assets.Asset, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        asset.grantRead(bindOptions.instanceRole);\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: asset.httpUrl,\n          }),\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetFileName, options);\n  }\n\n  public readonly elementType = InitElementType.FILE.toString();\n\n  protected constructor(private readonly fileName: string, private readonly options: InitFileOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(bindOptions: InitBindOptions): InitElementConfig {\n    for (const handle of this.options.serviceRestartHandles ?? []) {\n      handle._addFile(this.fileName);\n    }\n\n    return this._doBind(bindOptions);\n  }\n\n  /**\n   * Perform the actual bind and render\n   *\n   * This is in a second method so the superclass can guarantee that\n   * the common work of registering into serviceHandles cannot be forgotten.\n   * @internal\n   */\n  protected abstract _doBind(options: InitBindOptions): InitElementConfig;\n\n  /**\n   * Render the standard config block, given content vars\n   * @internal\n   */\n  protected _standardConfig(fileOptions: InitFileOptions, platform: InitPlatform, contentVars: Record<string, any>): Record<string, any> {\n    if (platform === InitPlatform.WINDOWS) {\n      if (fileOptions.group || fileOptions.owner || fileOptions.mode) {\n        throw new Error('Owner, group, and mode options not supported for Windows.');\n      }\n      return {\n        [this.fileName]: { ...contentVars },\n      };\n    }\n\n    return {\n      [this.fileName]: {\n        ...contentVars,\n        mode: fileOptions.mode || '000644',\n        owner: fileOptions.owner || 'root',\n        group: fileOptions.group || 'root',\n      },\n    };\n  }\n}\n\n                                                                                                  \nexport class InitGroup extends InitElement {\n\n                                                                       \n  public static fromName(groupName: string, groupId?: number): InitGroup {\n    return new InitGroup(groupName, groupId);\n  }\n\n  public readonly elementType = InitElementType.GROUP.toString();\n\n  protected constructor(private groupName: string, private groupId?: number) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    if (options.platform === InitPlatform.WINDOWS) {\n      throw new Error('Init groups are not supported on Windows');\n    }\n\n    return {\n      config: {\n        [this.groupName]: this.groupId !== undefined ? { gid: this.groupId } : {},\n      },\n    };\n  }\n\n}\n\n                                                        \nexport interface InitUserOptions {\n                                                                                 \n  readonly homeDir?: string;\n\n                                                                                                                                                                                                                                                                     \n  readonly userId?: number;\n\n                                                                                                                                                        \n  readonly groups?: string[];\n}\n\n                                                                                                                                                                                                                                       \nexport class InitUser extends InitElement {\n                                              \n  public static fromName(userName: string, options: InitUserOptions = {}): InitUser {\n    return new InitUser(userName, options);\n  }\n\n  public readonly elementType = InitElementType.USER.toString();\n\n  protected constructor(private readonly userName: string, private readonly userOptions: InitUserOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    if (options.platform === InitPlatform.WINDOWS) {\n      throw new Error('Init users are not supported on Windows');\n    }\n\n    return {\n      config: {\n        [this.userName]: {\n          uid: this.userOptions.userId,\n          groups: this.userOptions.groups,\n          homeDir: this.userOptions.homeDir,\n        },\n      },\n    };\n  }\n}\n\n                                                      \nexport interface LocationPackageOptions {\n                                                                                                                                                   \n  readonly key?: string;\n\n                                                                                                                     \n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n                                                         \nexport interface NamedPackageOptions {\n                                                                                                \n  readonly version?: string[];\n\n                                                                                                                      \n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n                                                         \nexport class InitPackage extends InitElement {\n                                                                      \n  public static rpm(location: string, options: LocationPackageOptions = {}): InitPackage {\n    return new InitPackage('rpm', [location], options.key, options.serviceRestartHandles);\n  }\n\n                                            \n  public static yum(packageName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('yum', options.version ?? [], packageName, options.serviceRestartHandles);\n  }\n\n                                                \n  public static rubyGem(gemName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('rubygems', options.version ?? [], gemName, options.serviceRestartHandles);\n  }\n\n                                            \n  public static python(packageName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('python', options.version ?? [], packageName, options.serviceRestartHandles);\n  }\n\n                                            \n  public static apt(packageName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('apt', options.version ?? [], packageName, options.serviceRestartHandles);\n  }\n\n                                                                              \n  public static msi(location: string, options: LocationPackageOptions = {}): InitPackage {\n    // The MSI package version must be a string, not an array.\n    return new class extends InitPackage {\n      protected renderPackageVersions() { return location; }\n    }('msi', [location], options.key, options.serviceRestartHandles);\n  }\n\n  public readonly elementType = InitElementType.PACKAGE.toString();\n\n  protected constructor(\n    private readonly type: string,\n    private readonly versions: string[],\n    private readonly packageName?: string,\n    private readonly serviceHandles?: InitServiceRestartHandle[],\n  ) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    if ((this.type === 'msi') !== (options.platform === InitPlatform.WINDOWS)) {\n      if (this.type === 'msi') {\n        throw new Error('MSI installers are only supported on Windows systems.');\n      } else {\n        throw new Error('Windows only supports the MSI package type');\n      }\n    }\n\n    if (!this.packageName && !['rpm', 'msi'].includes(this.type)) {\n      throw new Error('Package name must be specified for all package types besides RPM and MSI.');\n    }\n\n    const packageName = this.packageName || `${options.index}`.padStart(3, '0');\n\n    for (const handle of this.serviceHandles ?? []) {\n      handle._addPackage(this.type, packageName);\n    }\n\n    return {\n      config: {\n        [this.type]: {\n          [packageName]: this.renderPackageVersions(),\n        },\n      },\n    };\n  }\n\n  protected renderPackageVersions(): any {\n    return this.versions;\n  }\n}\n\n                                     \nexport interface InitServiceOptions {\n                                                                                                                                                                                                                                                                                                                                                                             \n  readonly enabled?: boolean;\n\n                                                                                                                                                                                                                                                                                                                       \n  readonly ensureRunning?: boolean;\n\n                                                                                                                                                                                                                                                                                                \n  readonly serviceRestartHandle?: InitServiceRestartHandle;\n}\n\n                                                                                           \nexport class InitService extends InitElement {\n                                                                             \n  public static enable(serviceName: string, options: InitServiceOptions = {}): InitService {\n    const { enabled, ensureRunning, ...otherOptions } = options;\n    return new InitService(serviceName, {\n      enabled: enabled ?? true,\n      ensureRunning: ensureRunning ?? enabled ?? true,\n      ...otherOptions,\n    });\n  }\n\n                                                   \n  public static disable(serviceName: string): InitService {\n    return new InitService(serviceName, { enabled: false, ensureRunning: false });\n  }\n\n  public readonly elementType = InitElementType.SERVICE.toString();\n\n  private constructor(private readonly serviceName: string, private readonly serviceOptions: InitServiceOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    const serviceManager = options.platform === InitPlatform.LINUX ? 'sysvinit' : 'windows';\n\n    return {\n      config: {\n        [serviceManager]: {\n          [this.serviceName]: {\n            enabled: this.serviceOptions.enabled,\n            ensureRunning: this.serviceOptions.ensureRunning,\n            ...this.serviceOptions.serviceRestartHandle?._renderRestartHandles(),\n          },\n        },\n      },\n    };\n  }\n\n}\n\n                                               \nexport interface InitSourceOptions {\n\n                                                                                                                                 \n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n                                                                                      \nexport interface InitSourceAssetOptions extends InitSourceOptions, s3_assets.AssetOptions {\n\n}\n\n                                              \nexport abstract class InitSource extends InitElement {\n                                                                       \n  public static fromUrl(targetDirectory: string, url: string, options: InitSourceOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind() {\n        return {\n          config: { [this.targetDirectory]: url },\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n                                                               \n  public static fromGitHub(targetDirectory: string, owner: string, repo: string, refSpec?: string, options: InitSourceOptions = {}): InitSource {\n    return InitSource.fromUrl(targetDirectory, `https://github.com/${owner}/${repo}/tarball/${refSpec ?? 'master'}`, options);\n  }\n\n                                                                                   \n  public static fromS3Object(targetDirectory: string, bucket: s3.IBucket, key: string, options: InitSourceOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind(bindOptions: InitBindOptions) {\n        bucket.grantRead(bindOptions.instanceRole, key);\n\n        return {\n          config: { [this.targetDirectory]: bucket.urlForObject(key) },\n          authentication: standardS3Auth(bindOptions.instanceRole, bucket.bucketName),\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n                                                                                \n  public static fromAsset(targetDirectory: string, path: string, options: InitSourceAssetOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind(bindOptions: InitBindOptions) {\n        const asset = new s3_assets.Asset(bindOptions.scope, `${targetDirectory}Asset`, {\n          path,\n          ...bindOptions,\n        });\n        asset.grantRead(bindOptions.instanceRole);\n\n        return {\n          config: { [this.targetDirectory]: asset.httpUrl },\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n                                                                      \n  public static fromExistingAsset(targetDirectory: string, asset: s3_assets.Asset, options: InitSourceOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind(bindOptions: InitBindOptions) {\n        asset.grantRead(bindOptions.instanceRole);\n\n        return {\n          config: { [this.targetDirectory]: asset.httpUrl },\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n  public readonly elementType = InitElementType.SOURCE.toString();\n\n  protected constructor(private readonly targetDirectory: string, private readonly serviceHandles?: InitServiceRestartHandle[]) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    for (const handle of this.serviceHandles ?? []) {\n      handle._addSource(this.targetDirectory);\n    }\n\n    // Delegate actual bind to subclasses\n    return this._doBind(options);\n  }\n\n  /**\n   * Perform the actual bind and render\n   *\n   * This is in a second method so the superclass can guarantee that\n   * the common work of registering into serviceHandles cannot be forgotten.\n   * @internal\n   */\n  protected abstract _doBind(options: InitBindOptions): InitElementConfig;\n}\n\n/**\n * Render a standard S3 auth block for use in AWS::CloudFormation::Authentication\n *\n * This block is the same every time (modulo bucket name), so it has the same\n * key every time so the blocks are merged into one in the final render.\n */\nfunction standardS3Auth(role: iam.IRole, bucketName: string) {\n  return {\n    S3AccessCreds: {\n      type: 'S3',\n      roleName: role.roleName,\n      buckets: [bucketName],\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
