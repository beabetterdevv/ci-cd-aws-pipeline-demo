{
  "version": 3,
  "sources": ["security-group.ts"],
  "sourcesContent": ["import * as cxschema from '../../cloud-assembly-schema';\nimport { Annotations, ContextProvider, IResource, Lazy, Names, Resource, ResourceProps, Stack, Token } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { Construct } from 'constructs';\nimport { Connections } from './connections';\nimport { CfnSecurityGroup, CfnSecurityGroupEgress, CfnSecurityGroupIngress } from './ec2.generated';\nimport { IPeer, Peer } from './peer';\nimport { Port } from './port';\nimport { IVpc } from './vpc';\n\nconst SECURITY_GROUP_SYMBOL = Symbol.for('@aws-cdk/iam.SecurityGroup');\n\nconst SECURITY_GROUP_DISABLE_INLINE_RULES_CONTEXT_KEY = '@aws-cdk/aws-ec2.securityGroupDisableInlineRules';\n\n                                                    \nexport interface ISecurityGroup extends IResource, IPeer {\n                                                                  \n  readonly securityGroupId: string;\n\n                                                                                            \n  readonly allowAllOutbound: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  addIngressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean): void;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean): void;\n}\n\n/**\n * A SecurityGroup that is not created in this template\n */\nabstract class SecurityGroupBase extends Resource implements ISecurityGroup {\n                                                                        \n  public static isSecurityGroup(x: any): x is SecurityGroupBase {\n    return SECURITY_GROUP_SYMBOL in x;\n  }\n\n  public abstract readonly securityGroupId: string;\n  public abstract readonly allowAllOutbound: boolean;\n\n  public readonly canInlineRule = false;\n  public readonly connections: Connections = new Connections({ securityGroups: [this] });\n  public readonly defaultPort?: Port;\n\n  private peerAsTokenCount: number = 0;\n\n  constructor(scope: Construct, id: string, props?: ResourceProps) {\n    super(scope, id, props);\n\n    Object.defineProperty(this, SECURITY_GROUP_SYMBOL, { value: true });\n  }\n\n  public get uniqueId() {\n    return Names.nodeUniqueId(this.node);\n  }\n\n  public addIngressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (description === undefined) {\n      description = `from ${peer.uniqueId}:${connection}`;\n    }\n\n    const [scope, id] = this.determineRuleScope(peer, connection, 'from', remoteRule);\n\n    // Skip duplicates\n    if (scope.node.tryFindChild(id) === undefined) {\n      new CfnSecurityGroupIngress(scope, id, {\n        groupId: this.securityGroupId,\n        ...peer.toIngressRuleConfig(),\n        ...connection.toRuleJson(),\n        description,\n      });\n    }\n  }\n\n  public addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (description === undefined) {\n      description = `to ${peer.uniqueId}:${connection}`;\n    }\n\n    const [scope, id] = this.determineRuleScope(peer, connection, 'to', remoteRule);\n\n    // Skip duplicates\n    if (scope.node.tryFindChild(id) === undefined) {\n      new CfnSecurityGroupEgress(scope, id, {\n        groupId: this.securityGroupId,\n        ...peer.toEgressRuleConfig(),\n        ...connection.toRuleJson(),\n        description,\n      });\n    }\n  }\n\n  public toIngressRuleConfig(): any {\n    return { sourceSecurityGroupId: this.securityGroupId };\n  }\n\n  public toEgressRuleConfig(): any {\n    return { destinationSecurityGroupId: this.securityGroupId };\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n\n  protected determineRuleScope(\n    peer: IPeer,\n    connection: Port,\n    fromTo: 'from' | 'to',\n    remoteRule?: boolean): [SecurityGroupBase, string] {\n\n    if (remoteRule && SecurityGroupBase.isSecurityGroup(peer) && differentStacks(this, peer)) {\n      // Reversed\n      const reversedFromTo = fromTo === 'from' ? 'to' : 'from';\n      return [peer, `${this.uniqueId}:${connection} ${reversedFromTo}`];\n    } else {\n      // Regular (do old ID escaping to in order to not disturb existing deployments)\n      return [this, `${fromTo} ${this.renderPeer(peer)}:${connection}`.replace('/', '_')];\n    }\n  }\n\n  private renderPeer(peer: IPeer) {\n    if (Token.isUnresolved(peer.uniqueId)) {\n      // Need to return a unique value each time a peer\n      // is an unresolved token, else the duplicate skipper\n      // in `sg.addXxxRule` can detect unique rules as duplicates\n      return this.peerAsTokenCount++ ? `'{IndirectPeer${this.peerAsTokenCount}}'` : '{IndirectPeer}';\n    } else {\n      return peer.uniqueId;\n    }\n  }\n}\n\nfunction differentStacks(group1: SecurityGroupBase, group2: SecurityGroupBase) {\n  return Stack.of(group1) !== Stack.of(group2);\n}\n\nexport interface SecurityGroupProps {\n                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly securityGroupName?: string;\n\n                                                                                                                           \n  readonly description?: string;\n\n                                                               \n  readonly vpc: IVpc;\n\n                                                                                                                                                                                                                                                                                                                                               \n  readonly allowAllOutbound?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  readonly disableInlineRules?: boolean;\n}\n\n                                                          \nexport interface SecurityGroupImportOptions {\n                                                                                                                                                                                                                                                                                                     \n  readonly allowAllOutbound?: boolean;\n\n                                                                                                                                                                                                                                                       \n  readonly mutable?: boolean;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nexport class SecurityGroup extends SecurityGroupBase {\n                                                                                                     \n  public static fromLookup(scope: Construct, id: string, securityGroupId: string) {\n    return this.fromLookupAttributes(scope, id, { securityGroupId });\n  }\n\n                                                \n  public static fromLookupById(scope: Construct, id: string, securityGroupId: string) {\n    return this.fromLookupAttributes(scope, id, { securityGroupId });\n  }\n\n                                                  \n  public static fromLookupByName(scope: Construct, id: string, securityGroupName: string, vpc: IVpc) {\n    return this.fromLookupAttributes(scope, id, { securityGroupName, vpc });\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                     \n  public static fromSecurityGroupId(scope: Construct, id: string, securityGroupId: string, options: SecurityGroupImportOptions = {}): ISecurityGroup {\n    class MutableImport extends SecurityGroupBase {\n      public securityGroupId = securityGroupId;\n      public allowAllOutbound = options.allowAllOutbound ?? true;\n\n      public addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n        // Only if allowAllOutbound has been disabled\n        if (options.allowAllOutbound === false) {\n          super.addEgressRule(peer, connection, description, remoteRule);\n        }\n      }\n    }\n\n    class ImmutableImport extends SecurityGroupBase {\n      public securityGroupId = securityGroupId;\n      public allowAllOutbound = options.allowAllOutbound ?? true;\n\n      public addEgressRule(_peer: IPeer, _connection: Port, _description?: string, _remoteRule?: boolean) {\n        // do nothing\n      }\n\n      public addIngressRule(_peer: IPeer, _connection: Port, _description?: string, _remoteRule?: boolean) {\n        // do nothing\n      }\n    }\n\n    return options.mutable !== false\n      ? new MutableImport(scope, id)\n      : new ImmutableImport(scope, id);\n  }\n\n  /**\n   * Look up a security group.\n   */\n  private static fromLookupAttributes(scope: Construct, id: string, options: SecurityGroupLookupOptions) {\n    if (Token.isUnresolved(options.securityGroupId) ||\u00A0Token.isUnresolved(options.securityGroupName) || Token.isUnresolved(options.vpc?.vpcId)) {\n      throw new Error('All arguments to look up a security group must be concrete (no Tokens)');\n    }\n\n    const attributes: cxapi.SecurityGroupContextResponse = ContextProvider.getValue(scope, {\n      provider: cxschema.ContextProvider.SECURITY_GROUP_PROVIDER,\n      props: {\n        securityGroupId: options.securityGroupId,\n        securityGroupName: options.securityGroupName,\n        vpcId: options.vpc?.vpcId,\n      },\n      dummyValue: {\n        securityGroupId: 'sg-12345',\n        allowAllOutbound: true,\n      } as cxapi.SecurityGroupContextResponse,\n    }).value;\n\n    return SecurityGroup.fromSecurityGroupId(scope, id, attributes.securityGroupId, {\n      allowAllOutbound: attributes.allowAllOutbound,\n      mutable: true,\n    });\n  }\n\n                                                                                                                                                                 \n  public readonly securityGroupName: string;\n\n                                                                  \n  public readonly securityGroupId: string;\n\n                                                                                \n  public readonly securityGroupVpcId: string;\n\n                                                                                            \n  public readonly allowAllOutbound: boolean;\n\n  private readonly securityGroup: CfnSecurityGroup;\n  private readonly directIngressRules: CfnSecurityGroup.IngressProperty[] = [];\n  private readonly directEgressRules: CfnSecurityGroup.EgressProperty[] = [];\n\n  /**\n   * Whether to disable optimization for inline security group rules.\n   */\n  private readonly disableInlineRules: boolean;\n\n  constructor(scope: Construct, id: string, props: SecurityGroupProps) {\n    super(scope, id, {\n      physicalName: props.securityGroupName,\n    });\n\n    const groupDescription = props.description || this.node.path;\n\n    this.allowAllOutbound = props.allowAllOutbound !== false;\n\n    this.disableInlineRules = props.disableInlineRules !== undefined ?\n      !!props.disableInlineRules :\n      !!this.node.tryGetContext(SECURITY_GROUP_DISABLE_INLINE_RULES_CONTEXT_KEY);\n\n    this.securityGroup = new CfnSecurityGroup(this, 'Resource', {\n      groupName: this.physicalName,\n      groupDescription,\n      securityGroupIngress: Lazy.any({ produce: () => this.directIngressRules }, { omitEmptyArray: true } ),\n      securityGroupEgress: Lazy.any({ produce: () => this.directEgressRules }, { omitEmptyArray: true } ),\n      vpcId: props.vpc.vpcId,\n    });\n\n    this.securityGroupId = this.securityGroup.attrGroupId;\n    this.securityGroupVpcId = this.securityGroup.attrVpcId;\n    this.securityGroupName = this.securityGroup.ref;\n\n    this.addDefaultEgressRule();\n  }\n\n  public addIngressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (!peer.canInlineRule || !connection.canInlineRule || this.disableInlineRules) {\n      super.addIngressRule(peer, connection, description, remoteRule);\n      return;\n    }\n\n    if (description === undefined) {\n      description = `from ${peer.uniqueId}:${connection}`;\n    }\n\n    this.addDirectIngressRule({\n      ...peer.toIngressRuleConfig(),\n      ...connection.toRuleJson(),\n      description,\n    });\n  }\n\n  public addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (this.allowAllOutbound) {\n      // In the case of \"allowAllOutbound\", we don't add any more rules. There\n      // is only one rule which allows all traffic and that subsumes any other\n      // rule.\n      if (!remoteRule) { // Warn only if addEgressRule() was explicitely called\n        Annotations.of(this).addWarning('Ignoring Egress rule since \\'allowAllOutbound\\' is set to true; To add customize rules, set allowAllOutbound=false on the SecurityGroup');\n      }\n      return;\n    } else {\n      // Otherwise, if the bogus rule exists we can now remove it because the\n      // presence of any other rule will get rid of EC2's implicit \"all\n      // outbound\" rule anyway.\n      this.removeNoTrafficRule();\n    }\n\n    if (!peer.canInlineRule || !connection.canInlineRule || this.disableInlineRules) {\n      super.addEgressRule(peer, connection, description, remoteRule);\n      return;\n    }\n\n    if (description === undefined) {\n      description = `from ${peer.uniqueId}:${connection}`;\n    }\n\n    const rule = {\n      ...peer.toEgressRuleConfig(),\n      ...connection.toRuleJson(),\n      description,\n    };\n\n    if (isAllTrafficRule(rule)) {\n      // We cannot allow this; if someone adds the rule in this way, it will be\n      // removed again if they add other rules. We also can't automatically switch\n      // to \"allOutbound=true\" mode, because we might have already emitted\n      // EgressRule objects (which count as rules added later) and there's no way\n      // to recall those. Better to prevent this for now.\n      throw new Error('Cannot add an \"all traffic\" egress rule in this way; set allowAllOutbound=true on the SecurityGroup instead.');\n    }\n\n    this.addDirectEgressRule(rule);\n  }\n\n  /**\n   * Add a direct ingress rule\n   */\n  private addDirectIngressRule(rule: CfnSecurityGroup.IngressProperty) {\n    if (!this.hasIngressRule(rule)) {\n      this.directIngressRules.push(rule);\n    }\n  }\n\n  /**\n   * Return whether the given ingress rule exists on the group\n   */\n  private hasIngressRule(rule: CfnSecurityGroup.IngressProperty): boolean {\n    return this.directIngressRules.findIndex(r => ingressRulesEqual(r, rule)) > -1;\n  }\n\n  /**\n   * Add a direct egress rule\n   */\n  private addDirectEgressRule(rule: CfnSecurityGroup.EgressProperty) {\n    if (!this.hasEgressRule(rule)) {\n      this.directEgressRules.push(rule);\n    }\n  }\n\n  /**\n   * Return whether the given egress rule exists on the group\n   */\n  private hasEgressRule(rule: CfnSecurityGroup.EgressProperty): boolean {\n    return this.directEgressRules.findIndex(r => egressRulesEqual(r, rule)) > -1;\n  }\n\n  /**\n   * Add the default egress rule to the securityGroup\n   *\n   * This depends on allowAllOutbound:\n   *\n   * - If allowAllOutbound is true, we *TECHNICALLY* don't need to do anything, because\n   *   EC2 is going to create this default rule anyway. But, for maximum readability\n   *   of the template, we will add one anyway.\n   * - If allowAllOutbound is false, we add a bogus rule that matches no traffic in\n   *   order to get rid of the default \"all outbound\" rule that EC2 creates by default.\n   *   If other rules happen to get added later, we remove the bogus rule again so\n   *   that it doesn't clutter up the template too much (even though that's not\n   *   strictly necessary).\n   */\n  private addDefaultEgressRule() {\n    if (this.disableInlineRules) {\n      const peer = this.allowAllOutbound ? ALL_TRAFFIC_PEER : NO_TRAFFIC_PEER;\n      const port = this.allowAllOutbound ? ALL_TRAFFIC_PORT : NO_TRAFFIC_PORT;\n      const description = this.allowAllOutbound ? ALLOW_ALL_RULE.description : MATCH_NO_TRAFFIC.description;\n      super.addEgressRule(peer, port, description, false);\n    } else {\n      const rule = this.allowAllOutbound? ALLOW_ALL_RULE : MATCH_NO_TRAFFIC;\n      this.directEgressRules.push(rule);\n    }\n  }\n\n  /**\n   * Remove the bogus rule if it exists\n   */\n  private removeNoTrafficRule() {\n    if (this.disableInlineRules) {\n      const [scope, id] = this.determineRuleScope(\n        NO_TRAFFIC_PEER,\n        NO_TRAFFIC_PORT,\n        'to',\n        false,\n      );\n      scope.node.tryRemoveChild(id);\n    } else {\n      const i = this.directEgressRules.findIndex(r => egressRulesEqual(r, MATCH_NO_TRAFFIC));\n      if (i > -1) {\n        this.directEgressRules.splice(i, 1);\n      }\n    }\n  }\n}\n\n/**\n * Egress rule that purposely matches no traffic\n *\n * This is used in order to disable the \"all traffic\" default of Security Groups.\n *\n * No machine can ever actually have the 255.255.255.255 IP address, but\n * in order to lock it down even more we'll restrict to a nonexistent\n * ICMP traffic type.\n */\nconst MATCH_NO_TRAFFIC = {\n  cidrIp: '255.255.255.255/32',\n  description: 'Disallow all traffic',\n  ipProtocol: 'icmp',\n  fromPort: 252,\n  toPort: 86,\n};\n\nconst NO_TRAFFIC_PEER = Peer.ipv4(MATCH_NO_TRAFFIC.cidrIp);\nconst NO_TRAFFIC_PORT = Port.icmpTypeAndCode(MATCH_NO_TRAFFIC.fromPort, MATCH_NO_TRAFFIC.toPort);\n\n/**\n * Egress rule that matches all traffic\n */\nconst ALLOW_ALL_RULE = {\n  cidrIp: '0.0.0.0/0',\n  description: 'Allow all outbound traffic by default',\n  ipProtocol: '-1',\n};\n\nconst ALL_TRAFFIC_PEER = Peer.anyIpv4();\nconst ALL_TRAFFIC_PORT = Port.allTraffic();\n\nexport interface ConnectionRule {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly protocol?: string;\n\n                                                                                                                                                                                                                          \n  readonly fromPort: number;\n\n                                                                                                                                                                                                                                                                                          \n  readonly toPort?: number;\n\n                                                                                                                                                   \n  readonly description?: string;\n}\n\n/**\n * Compare two ingress rules for equality the same way CloudFormation would (discarding description)\n */\nfunction ingressRulesEqual(a: CfnSecurityGroup.IngressProperty, b: CfnSecurityGroup.IngressProperty) {\n  return a.cidrIp === b.cidrIp\n    && a.cidrIpv6 === b.cidrIpv6\n    && a.fromPort === b.fromPort\n    && a.toPort === b.toPort\n    && a.ipProtocol === b.ipProtocol\n    && a.sourceSecurityGroupId === b.sourceSecurityGroupId\n    && a.sourceSecurityGroupName === b.sourceSecurityGroupName\n    && a.sourceSecurityGroupOwnerId === b.sourceSecurityGroupOwnerId;\n}\n\n/**\n * Compare two egress rules for equality the same way CloudFormation would (discarding description)\n */\nfunction egressRulesEqual(a: CfnSecurityGroup.EgressProperty, b: CfnSecurityGroup.EgressProperty) {\n  return a.cidrIp === b.cidrIp\n    && a.cidrIpv6 === b.cidrIpv6\n    && a.fromPort === b.fromPort\n    && a.toPort === b.toPort\n    && a.ipProtocol === b.ipProtocol\n    && a.destinationPrefixListId === b.destinationPrefixListId\n    && a.destinationSecurityGroupId === b.destinationSecurityGroupId;\n}\n\n/**\n * Whether this rule refers to all traffic\n */\nfunction isAllTrafficRule(rule: any) {\n  return rule.cidrIp === '0.0.0.0/0' && rule.ipProtocol === '-1';\n}\n\n/**\n * Properties for looking up an existing SecurityGroup.\n *\n * Either `securityGroupName` or `securityGroupId` has to be specified.\n */\ninterface SecurityGroupLookupOptions {\n  /**\n   * The name of the security group\n   *\n   * If given, will import the SecurityGroup with this name.\n   *\n   * @default Don't filter on securityGroupName\n   */\n  readonly securityGroupName?: string;\n\n  /**\n   * The ID of the security group\n   *\n   * If given, will import the SecurityGroup with this ID.\n   *\n   * @default Don't filter on securityGroupId\n   */\n  readonly securityGroupId?: string;\n\n  /**\n   * The VPC of the security group\n   *\n   * If given, will filter the SecurityGroup based on the VPC.\n   *\n   * @default Don't filter on VPC\n   */\n  readonly vpc?: IVpc,\n}\n"],
  "mappings": "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",
  "names": []
}
