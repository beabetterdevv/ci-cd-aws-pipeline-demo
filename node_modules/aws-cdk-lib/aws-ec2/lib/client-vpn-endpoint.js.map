{
  "version": 3,
  "sources": ["client-vpn-endpoint.ts"],
  "sourcesContent": ["import { ISamlProvider } from '../../aws-iam';\nimport * as logs from '../../aws-logs';\nimport { CfnOutput, Resource, Token } from '../../core';\nimport { Construct, DependencyGroup, IDependable } from 'constructs';\nimport { ClientVpnAuthorizationRule, ClientVpnAuthorizationRuleOptions } from './client-vpn-authorization-rule';\nimport { IClientVpnConnectionHandler, IClientVpnEndpoint, TransportProtocol, VpnPort } from './client-vpn-endpoint-types';\nimport { ClientVpnRoute, ClientVpnRouteOptions } from './client-vpn-route';\nimport { Connections } from './connections';\nimport { CfnClientVpnEndpoint, CfnClientVpnTargetNetworkAssociation } from './ec2.generated';\nimport { CidrBlock } from './network-util';\nimport { ISecurityGroup, SecurityGroup } from './security-group';\nimport { IVpc, SubnetSelection } from './vpc';\n\n                                            \nexport interface ClientVpnEndpointOptions {\n                                                                                                                                                                                                                                                                                                                                                                                            \n  readonly cidr: string;\n\n                                                                                                                                                                                                                                                                           \n  readonly clientCertificateArn?: string;\n\n                                                                                                                                                                                                              \n  readonly userBasedAuthentication?: ClientVpnUserBasedAuthentication;\n\n                                                                              \n  readonly logging?: boolean;\n\n                                                                                                               \n  readonly logGroup?: logs.ILogGroup;\n\n                                                                                                                 \n  readonly logStream?: logs.ILogStream;\n\n                                                                                                                                                                                                          \n  readonly clientConnectionHandler?: IClientVpnConnectionHandler;\n\n                                                                                                    \n  readonly description?: string;\n\n                                                                                                                         \n  readonly securityGroups?: ISecurityGroup[];\n\n                                                                                                                       \n  readonly selfServicePortal?: boolean;\n\n                                                  \n  readonly serverCertificateArn: string;\n\n                                                                                                                                                                                                               \n  readonly splitTunnel?: boolean;\n\n                                                                                                               \n  readonly transportProtocol?: TransportProtocol;\n\n                                                                                                                                    \n  readonly port?: VpnPort;\n\n                                                                                                                                                                                                                   \n  readonly dnsServers?: string[];\n\n                                                                                                               \n  readonly vpcSubnets?: SubnetSelection;\n\n                                                                                                                                                                                                                                               \n  readonly authorizeAllUsersToVpcCidr?: boolean;\n}\n\n                                                              \nexport abstract class ClientVpnUserBasedAuthentication {\n                                                \n  public static activeDirectory(directoryId: string): ClientVpnUserBasedAuthentication {\n    return new ActiveDirectoryAuthentication(directoryId);\n  }\n\n                                 \n  public static federated(samlProvider: ISamlProvider, selfServiceSamlProvider?: ISamlProvider): ClientVpnUserBasedAuthentication {\n    return new FederatedAuthentication(samlProvider, selfServiceSamlProvider);\n  }\n\n                                              \n  public abstract render(): any;\n}\n\n/**\n * Active Directory authentication\n */\nclass ActiveDirectoryAuthentication extends ClientVpnUserBasedAuthentication {\n  constructor(private readonly directoryId: string) {\n    super();\n  }\n\n  render(): any {\n    return {\n      type: 'directory-service-authentication',\n      activeDirectory: { directoryId: this.directoryId },\n    };\n  }\n}\n\n/**\n * Federated authentication\n */\nclass FederatedAuthentication extends ClientVpnUserBasedAuthentication {\n  constructor(private readonly samlProvider: ISamlProvider, private readonly selfServiceSamlProvider?: ISamlProvider) {\n    super();\n  }\n\n  render(): any {\n    return {\n      type: 'federated-authentication',\n      federatedAuthentication: {\n        samlProviderArn: this.samlProvider.samlProviderArn,\n        selfServiceSamlProviderArn: this.selfServiceSamlProvider?.samlProviderArn,\n      },\n    };\n  }\n}\n\n                                               \nexport interface ClientVpnEndpointProps extends ClientVpnEndpointOptions {\n                                       \n  readonly vpc: IVpc;\n}\n\n                                                                    \nexport interface ClientVpnEndpointAttributes {\n                                \n  readonly endpointId: string;\n\n                                                                 \n  readonly securityGroups: ISecurityGroup[];\n}\n\n                                   \nexport class ClientVpnEndpoint extends Resource implements IClientVpnEndpoint {\n                                                       \n  public static fromEndpointAttributes(scope: Construct, id: string, attrs: ClientVpnEndpointAttributes): IClientVpnEndpoint {\n    class Import extends Resource implements IClientVpnEndpoint {\n      public readonly endpointId = attrs.endpointId;\n      public readonly connections = new Connections({ securityGroups: attrs.securityGroups });\n      public readonly targetNetworksAssociated: IDependable = new DependencyGroup();\n    }\n    return new Import(scope, id);\n  }\n\n  public readonly endpointId: string;\n\n                                                                            \n  public readonly connections: Connections;\n\n  public readonly targetNetworksAssociated: IDependable;\n\n  private readonly _targetNetworksAssociated = new DependencyGroup();\n\n  constructor(scope: Construct, id: string, props: ClientVpnEndpointProps) {\n    super(scope, id);\n\n    if (!Token.isUnresolved(props.vpc.vpcCidrBlock)) {\n      const clientCidr = new CidrBlock(props.cidr);\n      const vpcCidr = new CidrBlock(props.vpc.vpcCidrBlock);\n      if (vpcCidr.containsCidr(clientCidr)) {\n        throw new Error('The client CIDR cannot overlap with the local CIDR of the VPC');\n      }\n    }\n\n    if (props.dnsServers && props.dnsServers.length > 2) {\n      throw new Error('A client VPN endpoint can have up to two DNS servers');\n    }\n\n    if (props.logging == false && (props.logGroup || props.logStream)) {\n      throw new Error('Cannot specify `logGroup` or `logStream` when logging is disabled');\n    }\n\n    if (props.clientConnectionHandler\n      && !Token.isUnresolved(props.clientConnectionHandler.functionName)\n      && !props.clientConnectionHandler.functionName.startsWith('AWSClientVPN-')) {\n      throw new Error('The name of the Lambda function must begin with the `AWSClientVPN-` prefix');\n    }\n\n    const logging = props.logging ?? true;\n    const logGroup = logging\n      ? props.logGroup ?? new logs.LogGroup(this, 'LogGroup')\n      : undefined;\n\n    const securityGroups = props.securityGroups ?? [new SecurityGroup(this, 'SecurityGroup', {\n      vpc: props.vpc,\n    })];\n    this.connections = new Connections({ securityGroups });\n\n    const endpoint = new CfnClientVpnEndpoint(this, 'Resource', {\n      authenticationOptions: renderAuthenticationOptions(props.clientCertificateArn, props.userBasedAuthentication),\n      clientCidrBlock: props.cidr,\n      clientConnectOptions: props.clientConnectionHandler\n        ? {\n          enabled: true,\n          lambdaFunctionArn: props.clientConnectionHandler.functionArn,\n        }\n        : undefined,\n      connectionLogOptions: {\n        enabled: logging,\n        cloudwatchLogGroup: logGroup?.logGroupName,\n        cloudwatchLogStream: props.logStream?.logStreamName,\n      },\n      description: props.description,\n      dnsServers: props.dnsServers,\n      securityGroupIds: securityGroups.map(s => s.securityGroupId),\n      selfServicePortal: booleanToEnabledDisabled(props.selfServicePortal),\n      serverCertificateArn: props.serverCertificateArn,\n      splitTunnel: props.splitTunnel,\n      transportProtocol: props.transportProtocol,\n      vpcId: props.vpc.vpcId,\n      vpnPort: props.port,\n    });\n\n    this.endpointId = endpoint.ref;\n\n    if (props.userBasedAuthentication && (props.selfServicePortal ?? true)) {\n      // Output self-service portal URL\n      new CfnOutput(this, 'SelfServicePortalUrl', {\n        value: `https://self-service.clientvpn.amazonaws.com/endpoints/${this.endpointId}`,\n      });\n    }\n\n    // Associate subnets\n    const subnetIds = props.vpc.selectSubnets(props.vpcSubnets).subnetIds;\n\n    if (Token.isUnresolved(subnetIds)) {\n      throw new Error('Cannot associate subnets when VPC are imported from parameters or exports containing lists of subnet IDs.');\n    }\n\n    for (const [idx, subnetId] of Object.entries(subnetIds)) {\n      this._targetNetworksAssociated.add(new CfnClientVpnTargetNetworkAssociation(this, `Association${idx}`, {\n        clientVpnEndpointId: this.endpointId,\n        subnetId,\n      }));\n    }\n    this.targetNetworksAssociated = this._targetNetworksAssociated;\n\n    if (props.authorizeAllUsersToVpcCidr ?? true) {\n      this.addAuthorizationRule('AuthorizeAll', {\n        cidr: props.vpc.vpcCidrBlock,\n      });\n    }\n  }\n\n                                                            \n  public addAuthorizationRule(id: string, props: ClientVpnAuthorizationRuleOptions): ClientVpnAuthorizationRule {\n    return new ClientVpnAuthorizationRule(this, id, {\n      ...props,\n      clientVpnEndpoint: this,\n    });\n  }\n\n                                              \n  public addRoute(id: string, props: ClientVpnRouteOptions): ClientVpnRoute {\n    return new ClientVpnRoute(this, id, {\n      ...props,\n      clientVpnEndpoint: this,\n    });\n  }\n}\n\nfunction renderAuthenticationOptions(\n  clientCertificateArn?: string,\n  userBasedAuthentication?: ClientVpnUserBasedAuthentication): CfnClientVpnEndpoint.ClientAuthenticationRequestProperty[] {\n  const authenticationOptions: CfnClientVpnEndpoint.ClientAuthenticationRequestProperty[] = [];\n\n  if (clientCertificateArn) {\n    authenticationOptions.push({\n      type: 'certificate-authentication',\n      mutualAuthentication: {\n        clientRootCertificateChainArn: clientCertificateArn,\n      },\n    });\n  }\n\n  if (userBasedAuthentication) {\n    authenticationOptions.push(userBasedAuthentication.render());\n  }\n\n  if (authenticationOptions.length === 0) {\n    throw new Error('A client VPN endpoint must use at least one authentication option');\n  }\n  return authenticationOptions;\n}\n\nfunction booleanToEnabledDisabled(val?: boolean): 'enabled' | 'disabled' | undefined {\n  switch (val) {\n    case undefined:\n      return undefined;\n    case true:\n      return 'enabled';\n    case false:\n      return 'disabled';\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
