{
  "version": 3,
  "sources": ["function.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport { IProfilingGroup, ProfilingGroup, ComputePlatform } from '../../aws-codeguruprofiler';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as logs from '../../aws-logs';\nimport * as sqs from '../../aws-sqs';\nimport { Annotations, ArnFormat, CfnResource, Duration, Fn, Lazy, Names, Stack } from '../../core';\nimport { Construct } from 'constructs';\nimport { Architecture } from './architecture';\nimport { Code, CodeConfig } from './code';\nimport { ICodeSigningConfig } from './code-signing-config';\nimport { EventInvokeConfigOptions } from './event-invoke-config';\nimport { IEventSource } from './event-source';\nimport { FileSystem } from './filesystem';\nimport { FunctionAttributes, FunctionBase, IFunction } from './function-base';\nimport { calculateFunctionHash, trimFromStart } from './function-hash';\nimport { Handler } from './handler';\nimport { LambdaInsightsVersion } from './lambda-insights';\nimport { Version, VersionOptions } from './lambda-version';\nimport { CfnFunction } from './lambda.generated';\nimport { LayerVersion, ILayerVersion } from './layers';\nimport { Runtime } from './runtime';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line\nimport { LogRetentionRetryOptions } from './log-retention';\n\n                                                                                                    \nexport enum Tracing {\n                                                                                                                                                                                   \n  ACTIVE = 'Active',\n                                                                                                                                  \n  PASS_THROUGH = 'PassThrough',\n                                                   \n  DISABLED = 'Disabled'\n}\n\n                              \nexport interface FunctionOptions extends EventInvokeConfigOptions {\n                                                                                    \n  readonly description?: string;\n\n                                                                                                                                                                                                                                                               \n  readonly timeout?: Duration;\n\n                                                                                                                                                                                                                                                                                                                                     \n  readonly environment?: { [key: string]: string };\n\n                                                                                                                                                                                                    \n  readonly functionName?: string;\n\n                                                                                                                                                                                                                                                                                     \n  readonly memorySize?: number;\n\n                                                                                                                                                                                                                                                             \n  readonly initialPolicy?: iam.PolicyStatement[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  readonly role?: iam.IRole;\n\n                                                                                                                                                                                                           \n  readonly vpc?: ec2.IVpc;\n\n                                                                                                                                                                                                                                                                                        \n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly securityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                                                                                                                                                                                                                          \n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n                                                                                                                                                                                                                           \n  readonly allowAllOutbound?: boolean;\n\n                                                                                                                                                                                                                                    \n  readonly deadLetterQueueEnabled?: boolean;\n\n                                                                                                                                                          \n  readonly deadLetterQueue?: sqs.IQueue;\n\n                                                                                                  \n  readonly tracing?: Tracing;\n\n                                                                                                                                                              \n  readonly profiling?: boolean;\n\n                                                                                                                                                                                                            \n  readonly profilingGroup?: IProfilingGroup;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  readonly insightsVersion?: LambdaInsightsVersion;\n\n                                                                                                                                                                                                                                                                                                                                         \n  readonly layers?: ILayerVersion[];\n\n                                                                                                                                                                                                                                     \n  readonly reservedConcurrentExecutions?: number;\n\n                                                                                                                                                         \n  readonly events?: IEventSource[];\n\n                                                                                                                                                                                                                                                                                    \n  readonly logRetention?: logs.RetentionDays;\n\n                                                                                                                                                                          \n  readonly logRetentionRole?: iam.IRole;\n\n                                                                                                                                                                                                                                                       \n  readonly logRetentionRetryOptions?: LogRetentionRetryOptions;\n\n                                                                                                                                                                                         \n  readonly currentVersionOptions?: VersionOptions;\n\n                                                                                                                        \n  readonly filesystem?: FileSystem;\n\n                                                                                                                                                                                                                                                                                                                                                                         \n  readonly allowPublicSubnet?: boolean;\n\n                                                                                                                                                                                         \n  readonly environmentEncryption?: kms.IKey;\n\n                                                                                                         \n  readonly codeSigningConfig?: ICodeSigningConfig;\n\n                                                                                                   \n  readonly architectures?: Architecture[];\n\n                                                                                                                 \n  readonly architecture?: Architecture;\n}\n\nexport interface FunctionProps extends FunctionOptions {\n                                                                                                                                                                                                                                                                      \n  readonly runtime: Runtime;\n\n                                                                                                                                                                                              \n  readonly code: Code;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly handler: string;\n}\n\n                                                                                                                                                                                                                                                                                                                                                           \nexport class Function extends FunctionBase {\n\n                                                                                                                                                                                                                                                                                                                                          \n  public get currentVersion(): Version {\n    if (this._currentVersion) {\n      return this._currentVersion;\n    }\n\n    this._currentVersion = new Version(this, 'CurrentVersion', {\n      lambda: this,\n      ...this.currentVersionOptions,\n    });\n\n    // override the version's logical ID with a lazy string which includes the\n    // hash of the function itself, so a new version resource is created when\n    // the function configuration changes.\n    const cfn = this._currentVersion.node.defaultChild as CfnResource;\n    const originalLogicalId = this.stack.resolve(cfn.logicalId) as string;\n\n    cfn.overrideLogicalId(Lazy.uncachedString({\n      produce: () => {\n        const hash = calculateFunctionHash(this);\n        const logicalId = trimFromStart(originalLogicalId, 255 - 32);\n        return `${logicalId}${hash}`;\n      },\n    }));\n\n    return this._currentVersion;\n  }\n\n  /** @internal */\n  public static _VER_PROPS: { [key: string]: boolean } = {};\n\n                                                                                                                                                                                                                                                                                                                                                                  \n  public static classifyVersionProperty(propertyName: string, locked: boolean) {\n    this._VER_PROPS[propertyName] = locked;\n  }\n\n                                                                    \n  public static fromFunctionArn(scope: Construct, id: string, functionArn: string): IFunction {\n    return Function.fromFunctionAttributes(scope, id, { functionArn });\n  }\n\n                                                                                                                                                                                                                                                                        \n  public static fromFunctionAttributes(scope: Construct, id: string, attrs: FunctionAttributes): IFunction {\n    const functionArn = attrs.functionArn;\n    const functionName = extractNameFromArn(attrs.functionArn);\n    const role = attrs.role;\n\n    class Import extends FunctionBase {\n      public readonly functionName = functionName;\n      public readonly functionArn = functionArn;\n      public readonly grantPrincipal: iam.IPrincipal;\n      public readonly role = role;\n      public readonly permissionsNode = this.node;\n      public readonly architecture = attrs.architecture ?? Architecture.X86_64;\n\n      protected readonly canCreatePermissions = attrs.sameEnvironment ?? this._isStackAccount();\n\n      constructor(s: Construct, i: string) {\n        super(s, i, {\n          environmentFromArn: functionArn,\n        });\n\n        this.grantPrincipal = role || new iam.UnknownPrincipal({ resource: this });\n\n        if (attrs.securityGroup) {\n          this._connections = new ec2.Connections({\n            securityGroups: [attrs.securityGroup],\n          });\n        } else if (attrs.securityGroupId) {\n          this._connections = new ec2.Connections({\n            securityGroups: [ec2.SecurityGroup.fromSecurityGroupId(scope, 'SecurityGroup', attrs.securityGroupId)],\n          });\n        }\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n                                                              \n  public static metricAll(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/Lambda',\n      metricName,\n      ...props,\n    });\n  }\n                                                                                                            \n  public static metricAllErrors(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Errors', { statistic: 'sum', ...props });\n  }\n\n                                                                                                        \n  public static metricAllDuration(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Duration', props);\n  }\n\n                                                                                                          \n  public static metricAllInvocations(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Invocations', { statistic: 'sum', ...props });\n  }\n\n                                                                                                                    \n  public static metricAllThrottles(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Throttles', { statistic: 'sum', ...props });\n  }\n\n                                                                                                                        \n  public static metricAllConcurrentExecutions(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    // Mini-FAQ: why max? This metric is a gauge that is emitted every\n    // minute, so either max or avg or a percentile make sense (but sum\n    // doesn't). Max is more sensitive to spiky load changes which is\n    // probably what you're interested in if you're looking at this metric\n    // (Load spikes may lead to concurrent execution errors that would\n    // otherwise not be visible in the avg)\n    return this.metricAll('ConcurrentExecutions', { statistic: 'max', ...props });\n  }\n\n                                                                                                                                   \n  public static metricAllUnreservedConcurrentExecutions(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('UnreservedConcurrentExecutions', { statistic: 'max', ...props });\n  }\n\n                                      \n  public readonly functionName: string;\n\n                                     \n  public readonly functionArn: string;\n\n                                                             \n  public readonly role?: iam.IRole;\n\n                                                        \n  public readonly runtime: Runtime;\n\n                                                                 \n  public readonly grantPrincipal: iam.IPrincipal;\n\n                                                                                              \n  public readonly deadLetterQueue?: sqs.IQueue;\n\n                                                                                                                 \n  public readonly architecture: Architecture;\n\n                                                        \n  public readonly timeout?: Duration;\n\n  public readonly permissionsNode = this.node;\n\n\n  protected readonly canCreatePermissions = true;\n\n  private readonly layers: ILayerVersion[] = [];\n\n  private _logGroup?: logs.ILogGroup;\n\n  /**\n   * Environment variables for this function\n   */\n  private environment: { [key: string]: EnvironmentConfig } = {};\n\n  private readonly currentVersionOptions?: VersionOptions;\n  private _currentVersion?: Version;\n\n  private _architecture?: Architecture;\n\n  constructor(scope: Construct, id: string, props: FunctionProps) {\n    super(scope, id, {\n      physicalName: props.functionName,\n    });\n\n    const managedPolicies = new Array<iam.IManagedPolicy>();\n\n    // the arn is in the form of - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n    managedPolicies.push(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'));\n\n    if (props.vpc) {\n      // Policy that will have ENI creation permissions\n      managedPolicies.push(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaVPCAccessExecutionRole'));\n    }\n\n    this.role = props.role || new iam.Role(this, 'ServiceRole', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n      managedPolicies,\n    });\n    this.grantPrincipal = this.role;\n\n    // add additional managed policies when necessary\n    if (props.filesystem) {\n      const config = props.filesystem.config;\n      if (config.policies) {\n        config.policies.forEach(p => {\n          this.role?.addToPrincipalPolicy(p);\n        });\n      }\n    }\n\n    for (const statement of (props.initialPolicy || [])) {\n      this.role.addToPrincipalPolicy(statement);\n    }\n\n    const code = props.code.bind(this);\n    verifyCodeConfig(code, props);\n\n    let profilingGroupEnvironmentVariables: { [key: string]: string } = {};\n    if (props.profilingGroup && props.profiling !== false) {\n      this.validateProfiling(props);\n      props.profilingGroup.grantPublish(this.role);\n      profilingGroupEnvironmentVariables = {\n        AWS_CODEGURU_PROFILER_GROUP_ARN: Stack.of(scope).formatArn({\n          service: 'codeguru-profiler',\n          resource: 'profilingGroup',\n          resourceName: props.profilingGroup.profilingGroupName,\n        }),\n        AWS_CODEGURU_PROFILER_ENABLED: 'TRUE',\n      };\n    } else if (props.profiling) {\n      this.validateProfiling(props);\n      const profilingGroup = new ProfilingGroup(this, 'ProfilingGroup', {\n        computePlatform: ComputePlatform.AWS_LAMBDA,\n      });\n      profilingGroup.grantPublish(this.role);\n      profilingGroupEnvironmentVariables = {\n        AWS_CODEGURU_PROFILER_GROUP_ARN: profilingGroup.profilingGroupArn,\n        AWS_CODEGURU_PROFILER_ENABLED: 'TRUE',\n      };\n    }\n\n    const env = { ...profilingGroupEnvironmentVariables, ...props.environment };\n    for (const [key, value] of Object.entries(env)) {\n      this.addEnvironment(key, value);\n    }\n\n    this.deadLetterQueue = this.buildDeadLetterQueue(props);\n\n    let fileSystemConfigs: CfnFunction.FileSystemConfigProperty[] | undefined = undefined;\n    if (props.filesystem) {\n      fileSystemConfigs = [{\n        arn: props.filesystem.config.arn,\n        localMountPath: props.filesystem.config.localMountPath,\n      }];\n    }\n\n    if (props.architecture && props.architectures !== undefined) {\n      throw new Error('Either architecture or architectures must be specified but not both.');\n    }\n    if (props.architectures && props.architectures.length > 1) {\n      throw new Error('Only one architecture must be specified.');\n    }\n    this._architecture = props.architecture ?? (props.architectures && props.architectures[0]);\n\n    const resource: CfnFunction = new CfnFunction(this, 'Resource', {\n      functionName: this.physicalName,\n      description: props.description,\n      code: {\n        s3Bucket: code.s3Location && code.s3Location.bucketName,\n        s3Key: code.s3Location && code.s3Location.objectKey,\n        s3ObjectVersion: code.s3Location && code.s3Location.objectVersion,\n        zipFile: code.inlineCode,\n        imageUri: code.image?.imageUri,\n      },\n      layers: Lazy.list({ produce: () => this.layers.map(layer => layer.layerVersionArn) }, { omitEmpty: true }), // Evaluated on synthesis\n      handler: props.handler === Handler.FROM_IMAGE ? undefined : props.handler,\n      timeout: props.timeout && props.timeout.toSeconds(),\n      packageType: props.runtime === Runtime.FROM_IMAGE ? 'Image' : undefined,\n      runtime: props.runtime === Runtime.FROM_IMAGE ? undefined : props.runtime.name,\n      role: this.role.roleArn,\n      // Uncached because calling '_checkEdgeCompatibility', which gets called in the resolve of another\n      // Token, actually *modifies* the 'environment' map.\n      environment: Lazy.uncachedAny({ produce: () => this.renderEnvironment() }),\n      memorySize: props.memorySize,\n      vpcConfig: this.configureVpc(props),\n      deadLetterConfig: this.buildDeadLetterConfig(this.deadLetterQueue),\n      tracingConfig: this.buildTracingConfig(props),\n      reservedConcurrentExecutions: props.reservedConcurrentExecutions,\n      imageConfig: undefinedIfNoKeys({\n        command: code.image?.cmd,\n        entryPoint: code.image?.entrypoint,\n        workingDirectory: code.image?.workingDirectory,\n      }),\n      kmsKeyArn: props.environmentEncryption?.keyArn,\n      fileSystemConfigs,\n      codeSigningConfigArn: props.codeSigningConfig?.codeSigningConfigArn,\n      architectures: this._architecture ? [this._architecture.name] : undefined,\n    });\n\n    resource.node.addDependency(this.role);\n\n    this.functionName = this.getResourceNameAttribute(resource.ref);\n    this.functionArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'lambda',\n      resource: 'function',\n      resourceName: this.physicalName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n\n    this.runtime = props.runtime;\n    this.timeout = props.timeout;\n\n    this.architecture = props.architecture ?? Architecture.X86_64;\n\n    if (props.layers) {\n      if (props.runtime === Runtime.FROM_IMAGE) {\n        throw new Error('Layers are not supported for container image functions');\n      }\n\n      this.addLayers(...props.layers);\n    }\n\n    for (const event of props.events || []) {\n      this.addEventSource(event);\n    }\n\n    // Log retention\n    if (props.logRetention) {\n      const logRetention = new logs.LogRetention(this, 'LogRetention', {\n        logGroupName: `/aws/lambda/${this.functionName}`,\n        retention: props.logRetention,\n        role: props.logRetentionRole,\n        logRetentionRetryOptions: props.logRetentionRetryOptions as logs.LogRetentionRetryOptions,\n      });\n      this._logGroup = logs.LogGroup.fromLogGroupArn(this, 'LogGroup', logRetention.logGroupArn);\n    }\n\n    props.code.bindToResource(resource);\n\n    // Event Invoke Config\n    if (props.onFailure || props.onSuccess || props.maxEventAge || props.retryAttempts !== undefined) {\n      this.configureAsyncInvoke({\n        onFailure: props.onFailure,\n        onSuccess: props.onSuccess,\n        maxEventAge: props.maxEventAge,\n        retryAttempts: props.retryAttempts,\n      });\n    }\n\n    this.currentVersionOptions = props.currentVersionOptions;\n\n    if (props.filesystem) {\n      if (!props.vpc) {\n        throw new Error('Cannot configure \\'filesystem\\' without configuring a VPC.');\n      }\n      const config = props.filesystem.config;\n      if (config.dependency) {\n        this.node.addDependency(...config.dependency);\n      }\n      // There could be a race if the Lambda is used in a CustomResource. It is possible for the Lambda to\n      // fail to attach to a given FileSystem if we do not have a dependency on the SecurityGroup ingress/egress\n      // rules that were created between this Lambda's SG & the Filesystem SG.\n      this.connections.securityGroups.forEach(sg => {\n        sg.node.findAll().forEach(child => {\n          if (child instanceof CfnResource && child.cfnResourceType === 'AWS::EC2::SecurityGroupEgress') {\n            resource.node.addDependency(child);\n          }\n        });\n      });\n      config.connections?.securityGroups.forEach(sg => {\n        sg.node.findAll().forEach(child => {\n          if (child instanceof CfnResource && child.cfnResourceType === 'AWS::EC2::SecurityGroupIngress') {\n            resource.node.addDependency(child);\n          }\n        });\n      });\n    }\n\n    // Configure Lambda insights\n    this.configureLambdaInsights(props);\n  }\n\n                                                                                                                                                                                                                                                                                                         \n  public addEnvironment(key: string, value: string, options?: EnvironmentOptions): this {\n    this.environment[key] = { value, ...options };\n    return this;\n  }\n\n                                                                                                                                                                                                                                                     \n  public addLayers(...layers: ILayerVersion[]): void {\n    for (const layer of layers) {\n      if (this.layers.length === 5) {\n        throw new Error('Unable to add layer: this lambda function already uses 5 layers.');\n      }\n      if (layer.compatibleRuntimes && !layer.compatibleRuntimes.find(runtime => runtime.runtimeEquals(this.runtime))) {\n        const runtimes = layer.compatibleRuntimes.map(runtime => runtime.name).join(', ');\n        throw new Error(`This lambda function uses a runtime that is incompatible with this layer (${this.runtime.name} is not in [${runtimes}])`);\n      }\n\n      // Currently no validations for compatible architectures since Lambda service\n      // allows layers configured with one architecture to be used with a Lambda function\n      // from another architecture.\n\n      this.layers.push(layer);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  public addVersion(\n    name: string,\n    codeSha256?: string,\n    description?: string,\n    provisionedExecutions?: number,\n    asyncInvokeConfig: EventInvokeConfigOptions = {}): Version {\n\n    return new Version(this, 'Version' + name, {\n      lambda: this,\n      codeSha256,\n      description,\n      provisionedConcurrentExecutions: provisionedExecutions,\n      ...asyncInvokeConfig,\n    });\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  public get logGroup(): logs.ILogGroup {\n    if (!this._logGroup) {\n      const logRetention = new logs.LogRetention(this, 'LogRetention', {\n        logGroupName: `/aws/lambda/${this.functionName}`,\n        retention: logs.RetentionDays.INFINITE,\n      });\n      this._logGroup = logs.LogGroup.fromLogGroupArn(this, `${this.node.id}-LogGroup`, logRetention.logGroupArn);\n    }\n    return this._logGroup;\n  }\n\n  /** @internal */\n  public _checkEdgeCompatibility(): void {\n    // Check env vars\n    const envEntries = Object.entries(this.environment);\n    for (const [key, config] of envEntries) {\n      if (config.removeInEdge) {\n        delete this.environment[key];\n        Annotations.of(this).addInfo(`Removed ${key} environment variable for Lambda@Edge compatibility`);\n      }\n    }\n    const envKeys = Object.keys(this.environment);\n    if (envKeys.length !== 0) {\n      throw new Error(`The function ${this.node.path} contains environment variables [${envKeys}] and is not compatible with Lambda@Edge. \\\nEnvironment variables can be marked for removal when used in Lambda@Edge by setting the \\'removeInEdge\\' property in the \\'addEnvironment()\\' API.`);\n    }\n\n    return;\n  }\n\n  /**\n   * Configured lambda insights on the function if specified. This is acheived by adding an imported layer which is added to the\n   * list of lambda layers on synthesis.\n   *\n   * https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versions.html\n   */\n  private configureLambdaInsights(props: FunctionProps): void {\n    if (props.insightsVersion === undefined) {\n      return;\n    }\n    if (props.runtime !== Runtime.FROM_IMAGE) {\n      // Layers cannot be added to Lambda container images. The image should have the insights agent installed.\n      // See https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-docker.html\n      this.addLayers(LayerVersion.fromLayerVersionArn(this, 'LambdaInsightsLayer', props.insightsVersion._bind(this, this).arn));\n    }\n    this.role?.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('CloudWatchLambdaInsightsExecutionRolePolicy'));\n  }\n\n  private renderEnvironment() {\n    if (!this.environment || Object.keys(this.environment).length === 0) {\n      return undefined;\n    }\n\n    const variables: { [key: string]: string } = {};\n    // Sort environment so the hash of the function used to create\n    // `currentVersion` is not affected by key order (this is how lambda does\n    // it). For backwards compatibility we do not sort environment variables in case\n    // _currentVersion is not defined. Otherwise, this would have invalidated\n    // the template, and for example, may cause unneeded updates for nested\n    // stacks.\n    const keys = this._currentVersion\n      ? Object.keys(this.environment).sort()\n      : Object.keys(this.environment);\n\n    for (const key of keys) {\n      variables[key] = this.environment[key].value;\n    }\n\n    return { variables };\n  }\n\n  /**\n   * If configured, set up the VPC-related properties\n   *\n   * Returns the VpcConfig that should be added to the\n   * Lambda creation properties.\n   */\n  private configureVpc(props: FunctionProps): CfnFunction.VpcConfigProperty | undefined {\n    if ((props.securityGroup || props.allowAllOutbound !== undefined) && !props.vpc) {\n      throw new Error('Cannot configure \\'securityGroup\\' or \\'allowAllOutbound\\' without configuring a VPC');\n    }\n\n    if (!props.vpc) { return undefined; }\n\n    if (props.securityGroup && props.allowAllOutbound !== undefined) {\n      throw new Error('Configure \\'allowAllOutbound\\' directly on the supplied SecurityGroup.');\n    }\n\n    let securityGroups: ec2.ISecurityGroup[];\n\n    if (props.securityGroup && props.securityGroups) {\n      throw new Error('Only one of the function props, securityGroup or securityGroups, is allowed');\n    }\n\n    if (props.securityGroups) {\n      securityGroups = props.securityGroups;\n    } else {\n      const securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'SecurityGroup', {\n        vpc: props.vpc,\n        description: 'Automatic security group for Lambda Function ' + Names.uniqueId(this),\n        allowAllOutbound: props.allowAllOutbound,\n      });\n      securityGroups = [securityGroup];\n    }\n\n    this._connections = new ec2.Connections({ securityGroups });\n\n    if (props.filesystem) {\n      if (props.filesystem.config.connections) {\n        props.filesystem.config.connections.allowDefaultPortFrom(this);\n      }\n    }\n\n    const allowPublicSubnet = props.allowPublicSubnet ?? false;\n    const { subnetIds } = props.vpc.selectSubnets(props.vpcSubnets);\n    const publicSubnetIds = new Set(props.vpc.publicSubnets.map(s => s.subnetId));\n    for (const subnetId of subnetIds) {\n      if (publicSubnetIds.has(subnetId) && !allowPublicSubnet) {\n        throw new Error('Lambda Functions in a public subnet can NOT access the internet. ' +\n          'If you are aware of this limitation and would still like to place the function int a public subnet, set `allowPublicSubnet` to true');\n      }\n    }\n\n    // List can't be empty here, if we got this far you intended to put your Lambda\n    // in subnets. We're going to guarantee that we get the nice error message by\n    // making VpcNetwork do the selection again.\n\n    return {\n      subnetIds,\n      securityGroupIds: securityGroups.map(sg => sg.securityGroupId),\n    };\n  }\n\n  private buildDeadLetterQueue(props: FunctionProps) {\n    if (props.deadLetterQueue && props.deadLetterQueueEnabled === false) {\n      throw Error('deadLetterQueue defined but deadLetterQueueEnabled explicitly set to false');\n    }\n\n    if (!props.deadLetterQueue && !props.deadLetterQueueEnabled) {\n      return undefined;\n    }\n\n    const deadLetterQueue = props.deadLetterQueue || new sqs.Queue(this, 'DeadLetterQueue', {\n      retentionPeriod: Duration.days(14),\n    });\n\n    this.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['sqs:SendMessage'],\n      resources: [deadLetterQueue.queueArn],\n    }));\n\n    return deadLetterQueue;\n  }\n\n  private buildDeadLetterConfig(deadLetterQueue?: sqs.IQueue) {\n    if (deadLetterQueue) {\n      return {\n        targetArn: deadLetterQueue.queueArn,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  private buildTracingConfig(props: FunctionProps) {\n    if (props.tracing === undefined || props.tracing === Tracing.DISABLED) {\n      return undefined;\n    }\n\n    this.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['xray:PutTraceSegments', 'xray:PutTelemetryRecords'],\n      resources: ['*'],\n    }));\n\n    return {\n      mode: props.tracing,\n    };\n  }\n\n  private validateProfiling(props: FunctionProps) {\n    if (!props.runtime.supportsCodeGuruProfiling) {\n      throw new Error(`CodeGuru profiling is not supported by runtime ${props.runtime.name}`);\n    }\n    if (props.environment && (props.environment.AWS_CODEGURU_PROFILER_GROUP_ARN || props.environment.AWS_CODEGURU_PROFILER_ENABLED)) {\n      throw new Error('AWS_CODEGURU_PROFILER_GROUP_ARN and AWS_CODEGURU_PROFILER_ENABLED must not be set when profiling options enabled');\n    }\n  }\n}\n\n                                        \nexport interface EnvironmentOptions {\n                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly removeInEdge?: boolean\n}\n\n/**\n * Configuration for an environment variable\n */\ninterface EnvironmentConfig extends EnvironmentOptions {\n  readonly value: string;\n}\n\n/**\n * Given an opaque (token) ARN, returns a CloudFormation expression that extracts the function\n * name from the ARN.\n *\n * Function ARNs look like this:\n *\n *   arn:aws:lambda:region:account-id:function:function-name\n *\n * ..which means that in order to extract the `function-name` component from the ARN, we can\n * split the ARN using \":\" and select the component in index 6.\n *\n * @returns `FnSelect(6, FnSplit(':', arn))`\n */\nfunction extractNameFromArn(arn: string) {\n  return Fn.select(6, Fn.split(':', arn));\n}\n\nexport function verifyCodeConfig(code: CodeConfig, props: FunctionProps) {\n  // mutually exclusive\n  const codeType = [code.inlineCode, code.s3Location, code.image];\n\n  if (codeType.filter(x => !!x).length !== 1) {\n    throw new Error('lambda.Code must specify exactly one of: \"inlineCode\", \"s3Location\", or \"image\"');\n  }\n\n  if (!!code.image === (props.handler !== Handler.FROM_IMAGE)) {\n    throw new Error('handler must be `Handler.FROM_IMAGE` when using image asset for Lambda function');\n  }\n\n  if (!!code.image === (props.runtime !== Runtime.FROM_IMAGE)) {\n    throw new Error('runtime must be `Runtime.FROM_IMAGE` when using image asset for Lambda function');\n  }\n\n  // if this is inline code, check that the runtime supports\n  if (code.inlineCode && !props.runtime.supportsInlineCode) {\n    throw new Error(`Inline source not allowed for ${props.runtime!.name}`);\n  }\n}\n\nfunction undefinedIfNoKeys<A>(struct: A): A | undefined {\n  const allUndefined = Object.values(struct).every(val => val === undefined);\n  return allUndefined ? undefined : struct;\n}\n"],
  "mappings": "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",
  "names": []
}
