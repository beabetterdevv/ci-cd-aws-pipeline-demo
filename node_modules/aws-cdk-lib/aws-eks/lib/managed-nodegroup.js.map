{
  "version": 3,
  "sources": ["managed-nodegroup.ts"],
  "sourcesContent": ["import { InstanceType, ISecurityGroup, SubnetSelection, InstanceArchitecture } from '../../aws-ec2';\nimport { IRole, ManagedPolicy, Role, ServicePrincipal } from '../../aws-iam';\nimport { IResource, Resource, Annotations, withResolved } from '../../core';\nimport { Construct, Node } from 'constructs';\nimport { Cluster, ICluster } from './cluster';\nimport { CfnNodegroup } from './eks.generated';\n\n                              \nexport interface INodegroup extends IResource {\n                                                      \n  readonly nodegroupName: string;\n}\n\n                                                                                                                                                                                                                                                                                      \nexport enum NodegroupAmiType {\n                                        \n  AL2_X86_64 = 'AL2_x86_64',\n                                                \n  AL2_X86_64_GPU = 'AL2_x86_64_GPU',\n                                        \n  AL2_ARM_64 = 'AL2_ARM_64',\n                                            \n  BOTTLEROCKET_ARM_64 = 'BOTTLEROCKET_ARM_64',\n                                     \n  BOTTLEROCKET_X86_64 = 'BOTTLEROCKET_x86_64',\n}\n\n                                                  \nexport enum CapacityType {\n                               \n  SPOT = 'SPOT',\n                                    \n  ON_DEMAND = 'ON_DEMAND'\n}\n\n                                                                                                                                                                                                      \nexport interface NodegroupRemoteAccess {\n                                                                                                                                   \n  readonly sshKeyName: string;\n                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly sourceSecurityGroups?: ISecurityGroup[];\n}\n\n                                                 \nexport interface LaunchTemplateSpec {\n                                       \n  readonly id: string;\n                                                                                                                                   \n  readonly version?: string;\n}\n\n                                                 \nexport enum TaintEffect {\n                           \n  NO_SCHEDULE = 'NO_SCHEDULE',\n                                 \n  PREFER_NO_SCHEDULE = 'PREFER_NO_SCHEDULE',\n                          \n  NO_EXECUTE = 'NO_EXECUTE',\n}\n\n                          \nexport interface TaintSpec {\n                                                      \n  readonly effect?: TaintEffect;\n                                                    \n  readonly key?: string;\n                                                      \n  readonly value?: string;\n}\n\n                                                          \nexport interface NodegroupOptions {\n                                                                       \n  readonly nodegroupName?: string;\n                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly subnets?: SubnetSelection;\n                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly amiType?: NodegroupAmiType;\n                                                                                                        \n  readonly diskSize?: number;\n                                                                                                                                                                                                      \n  readonly desiredSize?: number;\n                                                                                                                                                                                              \n  readonly maxSize?: number;\n                                                                                                                                                                        \n  readonly minSize?: number;\n                                                                                                                                                                                                                                                                                                                                                  \n  readonly forceUpdate?: boolean;\n                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly instanceType?: InstanceType;\n                                                                                                                                                                                                                                                                                         \n  readonly instanceTypes?: InstanceType[];\n                                                                                                                                    \n  readonly labels?: { [name: string]: string };\n                                                                                                                                    \n  readonly taints?: TaintSpec[];\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  readonly nodeRole?: IRole;\n                                                                                                                                                                                                                                             \n  readonly releaseVersion?: string;\n                                                                                                                                                                                                                                                                                                                                                      \n  readonly remoteAccess?: NodegroupRemoteAccess;\n                                                                                                                                                                                                                                                                                                                                                             \n  readonly tags?: { [name: string]: string };\n                                                                                                                                                                                           \n  readonly launchTemplateSpec?: LaunchTemplateSpec;\n                                                                                   \n  readonly capacityType?: CapacityType;\n}\n\n                                         \nexport interface NodegroupProps extends NodegroupOptions {\n                                 \n  readonly cluster: ICluster;\n}\n\n                                       \nexport class Nodegroup extends Resource implements INodegroup {\n                                                     \n  public static fromNodegroupName(scope: Construct, id: string, nodegroupName: string): INodegroup {\n    class Import extends Resource implements INodegroup {\n      public readonly nodegroupName = nodegroupName;\n    }\n    return new Import(scope, id);\n  }\n                                                          \n  public readonly nodegroupArn: string;\n                                                    \n  public readonly nodegroupName: string;\n                                                                                 \n  public readonly cluster: ICluster;\n                                                                   \n  public readonly role: IRole;\n\n  private readonly desiredSize: number;\n  private readonly maxSize: number;\n  private readonly minSize: number;\n\n  constructor(scope: Construct, id: string, props: NodegroupProps) {\n    super(scope, id, {\n      physicalName: props.nodegroupName,\n    });\n\n    this.cluster = props.cluster;\n\n    this.desiredSize = props.desiredSize ?? props.minSize ?? 2;\n    this.maxSize = props.maxSize ?? this.desiredSize;\n    this.minSize = props.minSize ?? 1;\n\n    withResolved(this.desiredSize, this.maxSize, (desired, max) => {\n      if (desired === undefined) {return ;}\n      if (desired > max) {\n        throw new Error(`Desired capacity ${desired} can't be greater than max size ${max}`);\n      }\n    });\n\n    withResolved(this.desiredSize, this.minSize, (desired, min) => {\n      if (desired === undefined) {return ;}\n      if (desired < min) {\n        throw new Error(`Minimum capacity ${min} can't be greater than desired size ${desired}`);\n      }\n    });\n\n    if (props.launchTemplateSpec && props.diskSize) {\n      // see - https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\n      // and https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-nodegroup.html#cfn-eks-nodegroup-disksize\n      throw new Error('diskSize must be specified within the launch template');\n    }\n\n    if (props.instanceType && props.instanceTypes) {\n      throw new Error('\"instanceType is deprecated, please use \"instanceTypes\" only.');\n    }\n\n    if (props.instanceType) {\n      Annotations.of(this).addWarning('\"instanceType\" is deprecated and will be removed in the next major version. please use \"instanceTypes\" instead');\n    }\n    const instanceTypes = props.instanceTypes ?? (props.instanceType ? [props.instanceType] : undefined);\n    let possibleAmiTypes: NodegroupAmiType[] = [];\n\n    if (instanceTypes && instanceTypes.length > 0) {\n      /**\n       * if the user explicitly configured instance types, we can't caculate the expected ami type as we support\n       * Amazon Linux 2 and Bottlerocket now. However we can check:\n       *\n       * 1. instance types of different CPU architectures are not mixed(e.g. X86 with ARM).\n       * 2. user-specified amiType should be included in `possibleAmiTypes`.\n       */\n      possibleAmiTypes = getPossibleAmiTypes(instanceTypes);\n\n      // if the user explicitly configured an ami type, make sure it's included in the possibleAmiTypes\n      if (props.amiType && !possibleAmiTypes.includes(props.amiType)) {\n        throw new Error(`The specified AMI does not match the instance types architecture, either specify one of ${possibleAmiTypes} or don't specify any`);\n      }\n    }\n\n    if (!props.nodeRole) {\n      const ngRole = new Role(this, 'NodeGroupRole', {\n        assumedBy: new ServicePrincipal('ec2.amazonaws.com'),\n      });\n\n      ngRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSWorkerNodePolicy'));\n      ngRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AmazonEKS_CNI_Policy'));\n      ngRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AmazonEC2ContainerRegistryReadOnly'));\n      this.role = ngRole;\n    } else {\n      this.role = props.nodeRole;\n    }\n\n    const resource = new CfnNodegroup(this, 'Resource', {\n      clusterName: this.cluster.clusterName,\n      nodegroupName: props.nodegroupName,\n      nodeRole: this.role.roleArn,\n      subnets: this.cluster.vpc.selectSubnets(props.subnets).subnetIds,\n      /**\n       * Case 1: If launchTemplate is explicitly specified with custom AMI, we cannot specify amiType, or the node group deployment will fail.\n       * As we don't know if the custom AMI is specified in the lauchTemplate, we just use props.amiType.\n       *\n       * Case 2: If launchTemplate is not specified, we try to determine amiType from the instanceTypes and it could be either AL2 or Bottlerocket.\n       * To avoid breaking changes, we use possibleAmiTypes[0] if amiType is undefined and make sure AL2 is always the first element in possibleAmiTypes\n       * as AL2 is previously the `expectedAmi` and this avoids breaking changes.\n       *\n       * That being said, users now either have to explicitly specify correct amiType or just leave it undefined.\n       */\n      amiType: props.launchTemplateSpec ? props.amiType : (props.amiType ?? possibleAmiTypes[0]),\n      capacityType: props.capacityType ? props.capacityType.valueOf() : undefined,\n      diskSize: props.diskSize,\n      forceUpdateEnabled: props.forceUpdate ?? true,\n\n      // note that we don't check if a launch template is configured here (even though it might configure instance types as well)\n      // because this doesn't have a default value, meaning the user had to explicitly configure this.\n      instanceTypes: instanceTypes?.map(t => t.toString()),\n      labels: props.labels,\n      taints: props.taints,\n      launchTemplate: props.launchTemplateSpec,\n      releaseVersion: props.releaseVersion,\n      remoteAccess: props.remoteAccess ? {\n        ec2SshKey: props.remoteAccess.sshKeyName,\n        sourceSecurityGroups: props.remoteAccess.sourceSecurityGroups ?\n          props.remoteAccess.sourceSecurityGroups.map(m => m.securityGroupId) : undefined,\n      } : undefined,\n      scalingConfig: {\n        desiredSize: this.desiredSize,\n        maxSize: this.maxSize,\n        minSize: this.minSize,\n      },\n      tags: props.tags,\n    });\n\n    // managed nodegroups update the `aws-auth` on creation, but we still need to track\n    // its state for consistency.\n    if (this.cluster instanceof Cluster) {\n      // see https://docs.aws.amazon.com/en_us/eks/latest/userguide/add-user-role.html\n      this.cluster.awsAuth.addRoleMapping(this.role, {\n        username: 'system:node:{{EC2PrivateDNSName}}',\n        groups: [\n          'system:bootstrappers',\n          'system:nodes',\n        ],\n      });\n\n      // the controller runs on the worker nodes so they cannot\n      // be deleted before the controller.\n      if (this.cluster.albController) {\n        Node.of(this.cluster.albController).addDependency(this);\n      }\n    }\n\n    this.nodegroupArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'eks',\n      resource: 'nodegroup',\n      resourceName: this.physicalName,\n    });\n    this.nodegroupName = this.getResourceNameAttribute(resource.ref);\n  }\n}\n\n/**\n * AMI types of different architectures. Make sure AL2 is always the first element, which will be the default\n * AmiType if amiType and launchTemplateSpec are both undefined.\n */\nconst arm64AmiTypes: NodegroupAmiType[] = [NodegroupAmiType.AL2_ARM_64, NodegroupAmiType.BOTTLEROCKET_ARM_64];\nconst x8664AmiTypes: NodegroupAmiType[] = [NodegroupAmiType.AL2_X86_64, NodegroupAmiType.BOTTLEROCKET_X86_64];\nconst gpuAmiTypes: NodegroupAmiType[] = [NodegroupAmiType.AL2_X86_64_GPU];\n\n\n/**\n * This function check if the instanceType is GPU instance.\n * @param instanceType The EC2 instance type\n */\nfunction isGpuInstanceType(instanceType: InstanceType): boolean {\n  // capture the family, generation, capabilities, and size portions of the instance type id\n  const instanceTypeComponents = instanceType.toString().match(/^([a-z]+)(\\d{1,2})([a-z]*)\\.([a-z0-9]+)$/);\n  if (instanceTypeComponents == null) {\n    throw new Error('Malformed instance type identifier');\n  }\n  const family = instanceTypeComponents[1];\n  return ['p', 'g', 'inf'].includes(family);\n}\n\ntype AmiArchitecture = InstanceArchitecture | 'GPU';\n/**\n * This function examines the CPU architecture of every instance type and determines\n * what AMI types are compatible for all of them. it either throws or produces an array of possible AMI types because\n * instance types of different CPU architectures are not supported.\n * @param instanceTypes The instance types\n * @returns NodegroupAmiType[]\n */\nfunction getPossibleAmiTypes(instanceTypes: InstanceType[]): NodegroupAmiType[] {\n  function typeToArch(instanceType: InstanceType): AmiArchitecture {\n    return isGpuInstanceType(instanceType) ? 'GPU' : instanceType.architecture;\n  }\n  const archAmiMap = new Map<AmiArchitecture, NodegroupAmiType[]>([\n    [InstanceArchitecture.ARM_64, arm64AmiTypes],\n    [InstanceArchitecture.X86_64, x8664AmiTypes],\n    ['GPU', gpuAmiTypes],\n  ]);\n  const architectures: Set<AmiArchitecture> = new Set(instanceTypes.map(typeToArch));\n\n  if (architectures.size === 0) { // protective code, the current implementation will never result in this.\n    throw new Error(`Cannot determine any ami type comptaible with instance types: ${instanceTypes.map(i => i.toString).join(',')}`);\n  }\n\n  if (architectures.size > 1) {\n    throw new Error('instanceTypes of different architectures is not allowed');\n  }\n\n  return archAmiMap.get(Array.from(architectures)[0])!;\n}\n"],
  "mappings": "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",
  "names": []
}
