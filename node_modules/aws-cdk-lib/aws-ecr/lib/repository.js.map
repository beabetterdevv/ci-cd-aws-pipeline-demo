{
  "version": 3,
  "sources": ["repository.ts"],
  "sourcesContent": ["import { EOL } from 'os';\nimport * as events from '../../aws-events';\nimport * as iam from '../../aws-iam';\nimport { ArnFormat, IResource, Lazy, RemovalPolicy, Resource, Stack, Token } from '../../core';\nimport { IConstruct, Construct } from 'constructs';\nimport { CfnRepository } from './ecr.generated';\nimport { LifecycleRule, TagStatus } from './lifecycle';\n\n                                        \nexport interface IRepository extends IResource {\n                                                           \n  readonly repositoryName: string;\n\n                                                          \n  readonly repositoryArn: string;\n\n                                                                                                                                                            \n  readonly repositoryUri: string;\n\n                                                                                                                                                                                                                                                                \n  repositoryUriForTag(tag?: string): string;\n\n                                                                                                                                                                                                                                                                                                \n  repositoryUriForDigest(digest?: string): string;\n\n                                                                           \n  addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;\n\n                                                                                                         \n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n                                                                                        \n  grantPull(grantee: iam.IGrantable): iam.Grant;\n\n                                                                                                 \n  grantPullPush(grantee: iam.IGrantable): iam.Grant;\n\n                                                                                                                                                                                                                                                                                                                                                 \n  onCloudTrailEvent(id: string, options?: events.OnEventOptions): events.Rule;\n\n                                                                                                                                                                                                                                                                                                                                                                               \n  onCloudTrailImagePushed(id: string, options?: OnCloudTrailImagePushedOptions): events.Rule;\n\n                                                                                                                                                                                                            \n  onImageScanCompleted(id: string, options?: OnImageScanCompletedOptions): events.Rule;\n\n                                                                                                                                                    \n  onEvent(id: string, options?: events.OnEventOptions): events.Rule;\n}\n\n                                                                                                      \nexport abstract class RepositoryBase extends Resource implements IRepository {\n                                           \n  public abstract readonly repositoryName: string;\n\n                                          \n  public abstract readonly repositoryArn: string;\n\n                                                                           \n  public abstract addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;\n\n                                                                                                                                            \n  public get repositoryUri() {\n    return this.repositoryUriForTag();\n  }\n\n                                                                                                                                                                                                 \n  public repositoryUriForTag(tag?: string): string {\n    const tagSuffix = tag ? `:${tag}` : '';\n    return this.repositoryUriWithSuffix(tagSuffix);\n  }\n\n                                                                                                                                                                                                          \n  public repositoryUriForDigest(digest?: string): string {\n    const digestSuffix = digest ? `@${digest}` : '';\n    return this.repositoryUriWithSuffix(digestSuffix);\n  }\n\n  /**\n   * Returns the repository URI, with an appended suffix, if provided.\n   * @param suffix An image tag or an image digest.\n   * @private\n   */\n  private repositoryUriWithSuffix(suffix?: string): string {\n    const parts = this.stack.splitArn(this.repositoryArn, ArnFormat.SLASH_RESOURCE_NAME);\n    return `${parts.account}.dkr.ecr.${parts.region}.${this.stack.urlSuffix}/${this.repositoryName}${suffix}`;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                 \n  public onCloudTrailEvent(id: string, options: events.OnEventOptions = {}): events.Rule {\n    const rule = new events.Rule(this, id, options);\n    rule.addTarget(options.target);\n    rule.addEventPattern({\n      source: ['aws.ecr'],\n      detailType: ['AWS API Call via CloudTrail'],\n      detail: {\n        requestParameters: {\n          repositoryName: [this.repositoryName],\n        },\n      },\n    });\n    return rule;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                               \n  public onCloudTrailImagePushed(id: string, options: OnCloudTrailImagePushedOptions = {}): events.Rule {\n    const rule = this.onCloudTrailEvent(id, options);\n    rule.addEventPattern({\n      detail: {\n        eventName: ['PutImage'],\n        requestParameters: {\n          imageTag: options.imageTag ? [options.imageTag] : undefined,\n        },\n      },\n    });\n    return rule;\n  }\n                                                                                                                                                                                                           \n  public onImageScanCompleted(id: string, options: OnImageScanCompletedOptions = {}): events.Rule {\n    const rule = new events.Rule(this, id, options);\n    rule.addTarget(options.target);\n    rule.addEventPattern({\n      source: ['aws.ecr'],\n      detailType: ['ECR Image Scan'],\n      detail: {\n        'repository-name': [this.repositoryName],\n        'scan-status': ['COMPLETE'],\n        'image-tags': options.imageTags ?? undefined,\n      },\n    });\n    return rule;\n  }\n\n                                                                                                                                                    \n  public onEvent(id: string, options: events.OnEventOptions = {}) {\n    const rule = new events.Rule(this, id, options);\n    rule.addEventPattern({\n      source: ['aws.ecr'],\n      resources: [this.repositoryArn],\n    });\n    rule.addTarget(options.target);\n    return rule;\n  }\n                                                                                                         \n  public grant(grantee: iam.IGrantable, ...actions: string[]) {\n    return iam.Grant.addToPrincipalOrResource({\n      grantee,\n      actions,\n      resourceArns: [this.repositoryArn],\n      resourceSelfArns: [],\n      resource: this,\n    });\n  }\n\n                                                                                          \n  public grantPull(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, 'ecr:BatchCheckLayerAvailability', 'ecr:GetDownloadUrlForLayer', 'ecr:BatchGetImage');\n\n    iam.Grant.addToPrincipal({\n      grantee,\n      actions: ['ecr:GetAuthorizationToken'],\n      resourceArns: ['*'],\n      scope: this,\n    });\n\n    return ret;\n  }\n\n                                                                                                 \n  public grantPullPush(grantee: iam.IGrantable) {\n    this.grantPull(grantee);\n    return this.grant(grantee,\n      'ecr:PutImage',\n      'ecr:InitiateLayerUpload',\n      'ecr:UploadLayerPart',\n      'ecr:CompleteLayerUpload');\n  }\n}\n\n                                                         \nexport interface OnCloudTrailImagePushedOptions extends events.OnEventOptions {\n                                                                                                    \n  readonly imageTag?: string;\n}\n\n                                                      \nexport interface OnImageScanCompletedOptions extends events.OnEventOptions {\n                                                                                                                                                                                                   \n  readonly imageTags?: string[];\n}\n\nexport interface RepositoryProps {\n                                                                                          \n  readonly repositoryName?: string;\n\n                                                                                                  \n  readonly lifecycleRules?: LifecycleRule[];\n\n                                                                                                                                                                                                                                                  \n  readonly lifecycleRegistryId?: string;\n\n                                                                                                                                     \n  readonly removalPolicy?: RemovalPolicy;\n\n                                                                                               \n  readonly imageScanOnPush?: boolean;\n\n                                                                                                                                                                                                                                  \n  readonly imageTagMutability?: TagMutability;\n}\n\nexport interface RepositoryAttributes {\n  readonly repositoryName: string;\n  readonly repositoryArn: string;\n}\n\n                                   \nexport class Repository extends RepositoryBase {\n                                    \n  public static fromRepositoryAttributes(scope: Construct, id: string, attrs: RepositoryAttributes): IRepository {\n    class Import extends RepositoryBase {\n      public readonly repositoryName = attrs.repositoryName;\n      public readonly repositoryArn = attrs.repositoryArn;\n\n      public addToResourcePolicy(_statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n        // dropped\n        return { statementAdded: false };\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  public static fromRepositoryArn(scope: Construct, id: string, repositoryArn: string): IRepository {\n\n    // if repositoryArn is a token, the repository name is also required. this is because\n    // repository names can include \"/\" (e.g. foo/bar/myrepo) and it is impossible to\n    // parse the name from an ARN using CloudFormation's split/select.\n    if (Token.isUnresolved(repositoryArn)) {\n      throw new Error('\"repositoryArn\" is a late-bound value, and therefore \"repositoryName\" is required. Use `fromRepositoryAttributes` instead');\n    }\n\n    const repositoryName = repositoryArn.split('/').slice(1).join('/');\n\n    class Import extends RepositoryBase {\n      public repositoryName = repositoryName;\n      public repositoryArn = repositoryArn;\n\n      public addToResourcePolicy(_statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n        // dropped\n        return { statementAdded: false };\n      }\n    }\n\n    return new Import(scope, id, {\n      environmentFromArn: repositoryArn,\n    });\n  }\n\n  public static fromRepositoryName(scope: Construct, id: string, repositoryName: string): IRepository {\n    class Import extends RepositoryBase {\n      public repositoryName = repositoryName;\n      public repositoryArn = Repository.arnForLocalRepository(repositoryName, scope);\n\n      public addToResourcePolicy(_statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n        // dropped\n        return { statementAdded: false };\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n                                                                                                                       \n  public static arnForLocalRepository(repositoryName: string, scope: IConstruct, account?: string): string {\n    return Stack.of(scope).formatArn({\n      account,\n      service: 'ecr',\n      resource: 'repository',\n      resourceName: repositoryName,\n    });\n  }\n\n\n  private static validateRepositoryName(physicalName: string) {\n    const repositoryName = physicalName;\n    if (!repositoryName || Token.isUnresolved(repositoryName)) {\n      // the name is a late-bound value, not a defined string,\n      // so skip validation\n      return;\n    }\n\n    const errors: string[] = [];\n\n    // Rules codified from https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html\n    if (repositoryName.length < 2 || repositoryName.length > 256) {\n      errors.push('Repository name must be at least 2 and no more than 256 characters');\n    }\n    const isPatternMatch = /^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*\\/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$/.test(repositoryName);\n    if (!isPatternMatch) {\n      errors.push('Repository name must follow the specified pattern: (?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*');\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Invalid ECR repository name (value: ${repositoryName})${EOL}${errors.join(EOL)}`);\n    }\n  }\n\n  public readonly repositoryName: string;\n  public readonly repositoryArn: string;\n  private readonly lifecycleRules = new Array<LifecycleRule>();\n  private readonly registryId?: string;\n  private policyDocument?: iam.PolicyDocument;\n\n  constructor(scope: Construct, id: string, props: RepositoryProps = {}) {\n    super(scope, id, {\n      physicalName: props.repositoryName,\n    });\n\n    Repository.validateRepositoryName(this.physicalName);\n\n    const resource = new CfnRepository(this, 'Resource', {\n      repositoryName: this.physicalName,\n      // It says \"Text\", but they actually mean \"Object\".\n      repositoryPolicyText: Lazy.any({ produce: () => this.policyDocument }),\n      lifecyclePolicy: Lazy.any({ produce: () => this.renderLifecyclePolicy() }),\n      imageScanningConfiguration: !props.imageScanOnPush ? undefined : {\n        scanOnPush: true,\n      },\n      imageTagMutability: props.imageTagMutability || undefined,\n    });\n\n    resource.applyRemovalPolicy(props.removalPolicy);\n\n    this.registryId = props.lifecycleRegistryId;\n    if (props.lifecycleRules) {\n      props.lifecycleRules.forEach(this.addLifecycleRule.bind(this));\n    }\n\n    this.repositoryName = this.getResourceNameAttribute(resource.ref);\n    this.repositoryArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'ecr',\n      resource: 'repository',\n      resourceName: this.physicalName,\n    });\n\n    this.node.addValidation({ validate: () => this.policyDocument?.validateForResourcePolicy() ?? [] });\n  }\n\n  public addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n    if (this.policyDocument === undefined) {\n      this.policyDocument = new iam.PolicyDocument();\n    }\n    this.policyDocument.addStatements(statement);\n    return { statementAdded: false, policyDependable: this.policyDocument };\n  }\n\n                                                                                                                                                                       \n  public addLifecycleRule(rule: LifecycleRule) {\n    // Validate rule here so users get errors at the expected location\n    if (rule.tagStatus === undefined) {\n      rule = { ...rule, tagStatus: rule.tagPrefixList === undefined ? TagStatus.ANY : TagStatus.TAGGED };\n    }\n\n    if (rule.tagStatus === TagStatus.TAGGED && (rule.tagPrefixList === undefined || rule.tagPrefixList.length === 0)) {\n      throw new Error('TagStatus.Tagged requires the specification of a tagPrefixList');\n    }\n    if (rule.tagStatus !== TagStatus.TAGGED && rule.tagPrefixList !== undefined) {\n      throw new Error('tagPrefixList can only be specified when tagStatus is set to Tagged');\n    }\n    if ((rule.maxImageAge !== undefined) === (rule.maxImageCount !== undefined)) {\n      throw new Error(`Life cycle rule must contain exactly one of 'maxImageAge' and 'maxImageCount', got: ${JSON.stringify(rule)}`);\n    }\n\n    if (rule.tagStatus === TagStatus.ANY && this.lifecycleRules.filter(r => r.tagStatus === TagStatus.ANY).length > 0) {\n      throw new Error('Life cycle can only have one TagStatus.Any rule');\n    }\n\n    this.lifecycleRules.push({ ...rule });\n  }\n\n  /**\n   * Render the life cycle policy object\n   */\n  private renderLifecyclePolicy(): CfnRepository.LifecyclePolicyProperty | undefined {\n    const stack = Stack.of(this);\n    let lifecyclePolicyText: any;\n\n    if (this.lifecycleRules.length === 0 && !this.registryId) { return undefined; }\n\n    if (this.lifecycleRules.length > 0) {\n      lifecyclePolicyText = JSON.stringify(stack.resolve({\n        rules: this.orderedLifecycleRules().map(renderLifecycleRule),\n      }));\n    }\n\n    return {\n      lifecyclePolicyText,\n      registryId: this.registryId,\n    };\n  }\n\n  /**\n   * Return life cycle rules with automatic ordering applied.\n   *\n   * Also applies validation of the 'any' rule.\n   */\n  private orderedLifecycleRules(): LifecycleRule[] {\n    if (this.lifecycleRules.length === 0) { return []; }\n\n    const prioritizedRules = this.lifecycleRules.filter(r => r.rulePriority !== undefined && r.tagStatus !== TagStatus.ANY);\n    const autoPrioritizedRules = this.lifecycleRules.filter(r => r.rulePriority === undefined && r.tagStatus !== TagStatus.ANY);\n    const anyRules = this.lifecycleRules.filter(r => r.tagStatus === TagStatus.ANY);\n    if (anyRules.length > 0 && anyRules[0].rulePriority !== undefined && autoPrioritizedRules.length > 0) {\n      // Supporting this is too complex for very little value. We just prohibit it.\n      throw new Error(\"Cannot combine prioritized TagStatus.Any rule with unprioritized rules. Remove rulePriority from the 'Any' rule.\");\n    }\n\n    const prios = prioritizedRules.map(r => r.rulePriority!);\n    let autoPrio = (prios.length > 0 ? Math.max(...prios) : 0) + 1;\n\n    const ret = new Array<LifecycleRule>();\n    for (const rule of prioritizedRules.concat(autoPrioritizedRules).concat(anyRules)) {\n      ret.push({\n        ...rule,\n        rulePriority: rule.rulePriority ?? autoPrio++,\n      });\n    }\n\n    // Do validation on the final array--might still be wrong because the user supplied all prios, but incorrectly.\n    validateAnyRuleLast(ret);\n    return ret;\n  }\n}\n\nfunction validateAnyRuleLast(rules: LifecycleRule[]) {\n  const anyRules = rules.filter(r => r.tagStatus === TagStatus.ANY);\n  if (anyRules.length === 1) {\n    const maxPrio = Math.max(...rules.map(r => r.rulePriority!));\n    if (anyRules[0].rulePriority !== maxPrio) {\n      throw new Error(`TagStatus.Any rule must have highest priority, has ${anyRules[0].rulePriority} which is smaller than ${maxPrio}`);\n    }\n  }\n}\n\n/**\n * Render the lifecycle rule to JSON\n */\nfunction renderLifecycleRule(rule: LifecycleRule) {\n  return {\n    rulePriority: rule.rulePriority,\n    description: rule.description,\n    selection: {\n      tagStatus: rule.tagStatus || TagStatus.ANY,\n      tagPrefixList: rule.tagPrefixList,\n      countType: rule.maxImageAge !== undefined ? CountType.SINCE_IMAGE_PUSHED : CountType.IMAGE_COUNT_MORE_THAN,\n      countNumber: rule.maxImageAge?.toDays() ?? rule.maxImageCount,\n      countUnit: rule.maxImageAge !== undefined ? 'days' : undefined,\n    },\n    action: {\n      type: 'expire',\n    },\n  };\n}\n\n/**\n * Select images based on counts\n */\nconst enum CountType {\n  /**\n   * Set a limit on the number of images in your repository\n   */\n  IMAGE_COUNT_MORE_THAN = 'imageCountMoreThan',\n\n  /**\n   * Set an age limit on the images in your repository\n   */\n  SINCE_IMAGE_PUSHED = 'sinceImagePushed',\n}\n\n                                                          \nexport enum TagMutability {\n                                                    \n  MUTABLE = 'MUTABLE',\n\n                                                                                                                       \n  IMMUTABLE = 'IMMUTABLE',\n\n}\n"],
  "mappings": "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",
  "names": []
}
