{
  "version": 3,
  "sources": ["cloud-assembly.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as cxschema from '../../cloud-assembly-schema';\nimport { CloudFormationStackArtifact } from './artifacts/cloudformation-artifact';\nimport { NestedCloudAssemblyArtifact } from './artifacts/nested-cloud-assembly-artifact';\nimport { TreeCloudArtifact } from './artifacts/tree-cloud-artifact';\nimport { CloudArtifact } from './cloud-artifact';\nimport { topologicalSort } from './toposort';\n\n/**\n * The name of the root manifest file of the assembly.\n */\nconst MANIFEST_FILE = 'manifest.json';\n\n                                                     \nexport class CloudAssembly {\n                                                          \n  public readonly directory: string;\n\n                                                             \n  public readonly version: string;\n\n                                                         \n  public readonly artifacts: CloudArtifact[];\n\n                                                                                              \n  public readonly runtime: cxschema.RuntimeInfo;\n\n                                           \n  public readonly manifest: cxschema.AssemblyManifest;\n\n                                                                                                                               \n  constructor(directory: string) {\n    this.directory = directory;\n\n    this.manifest = cxschema.Manifest.loadAssemblyManifest(path.join(directory, MANIFEST_FILE));\n    this.version = this.manifest.version;\n    this.artifacts = this.renderArtifacts();\n    this.runtime = this.manifest.runtime || { libraries: { } };\n\n    // force validation of deps by accessing 'depends' on all artifacts\n    this.validateDeps();\n  }\n\n                                                                                                                                                                                                             \n  public tryGetArtifact(id: string): CloudArtifact | undefined {\n    return this.artifacts.find(a => a.id === id);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public getStackByName(stackName: string): CloudFormationStackArtifact {\n    const artifacts = this.artifacts.filter(a => a instanceof CloudFormationStackArtifact && a.stackName === stackName);\n    if (!artifacts || artifacts.length === 0) {\n      throw new Error(`Unable to find stack with stack name \"${stackName}\"`);\n    }\n\n    if (artifacts.length > 1) {\n      // eslint-disable-next-line max-len\n      throw new Error(`There are multiple stacks with the stack name \"${stackName}\" (${artifacts.map(a => a.id).join(',')}). Use \"getStackArtifact(id)\" instead`);\n    }\n\n    return artifacts[0] as CloudFormationStackArtifact;\n  }\n\n                                                                                                                                                             \n  public getStack(stackName: string) {\n    return this.getStackByName(stackName);\n  }\n\n                                                                                                                                                                                                                                                                                                 \n  public getStackArtifact(artifactId: string): CloudFormationStackArtifact {\n    const artifact = this.tryGetArtifactRecursively(artifactId);\n\n    if (!artifact) {\n      throw new Error(`Unable to find artifact with id \"${artifactId}\"`);\n    }\n\n    if (!(artifact instanceof CloudFormationStackArtifact)) {\n      throw new Error(`Artifact ${artifactId} is not a CloudFormation stack`);\n    }\n\n    return artifact;\n  }\n\n  private tryGetArtifactRecursively(artifactId: string): CloudArtifact | undefined {\n    return this.stacksRecursively.find(a => a.id === artifactId);\n  }\n\n                                                                                \n  public get stacksRecursively(): CloudFormationStackArtifact[] {\n    function search(stackArtifacts: CloudFormationStackArtifact[], assemblies: CloudAssembly[]): CloudFormationStackArtifact[] {\n      if (assemblies.length === 0) {\n        return stackArtifacts;\n      }\n\n      const [head, ...tail] = assemblies;\n      const nestedAssemblies = head.nestedAssemblies.map(asm => asm.nestedAssembly);\n      return search(stackArtifacts.concat(head.stacks), tail.concat(nestedAssemblies));\n    };\n\n    return search([], [this]);\n  }\n\n                                                                                                                       \n  public getNestedAssemblyArtifact(artifactId: string): NestedCloudAssemblyArtifact {\n    const artifact = this.tryGetArtifact(artifactId);\n    if (!artifact) {\n      throw new Error(`Unable to find artifact with id \"${artifactId}\"`);\n    }\n\n    if (!(artifact instanceof NestedCloudAssemblyArtifact)) {\n      throw new Error(`Found artifact '${artifactId}' but it's not a nested cloud assembly`);\n    }\n\n    return artifact;\n  }\n\n                                                                                                              \n  public getNestedAssembly(artifactId: string): CloudAssembly {\n    return this.getNestedAssemblyArtifact(artifactId).nestedAssembly;\n  }\n\n                                                                                                                                                                                                                                             \n  public tree(): TreeCloudArtifact | undefined {\n    const trees = this.artifacts.filter(a => a.manifest.type === cxschema.ArtifactType.CDK_TREE);\n    if (trees.length === 0) {\n      return undefined;\n    } else if (trees.length > 1) {\n      throw new Error(`Multiple artifacts of type ${cxschema.ArtifactType.CDK_TREE} found in manifest`);\n    }\n    const tree = trees[0];\n\n    if (!(tree instanceof TreeCloudArtifact)) {\n      throw new Error('\"Tree\" artifact is not of expected type');\n    }\n\n    return tree;\n  }\n\n                                                                                                    \n  public get stacks(): CloudFormationStackArtifact[] {\n    return this.artifacts.filter(isCloudFormationStackArtifact);\n\n    function isCloudFormationStackArtifact(x: any): x is CloudFormationStackArtifact {\n      return x instanceof CloudFormationStackArtifact;\n    }\n  }\n\n                                                               \n  public get nestedAssemblies(): NestedCloudAssemblyArtifact[] {\n    return this.artifacts.filter(isNestedCloudAssemblyArtifact);\n\n    function isNestedCloudAssemblyArtifact(x: any): x is NestedCloudAssemblyArtifact {\n      return x instanceof NestedCloudAssemblyArtifact;\n    }\n  }\n\n  private validateDeps() {\n    for (const artifact of this.artifacts) {\n      ignore(artifact.dependencies);\n    }\n  }\n\n  private renderArtifacts() {\n    const result = new Array<CloudArtifact>();\n    for (const [name, artifact] of Object.entries(this.manifest.artifacts || { })) {\n      const cloudartifact = CloudArtifact.fromManifest(this, name, artifact);\n      if (cloudartifact) {\n        result.push(cloudartifact);\n      }\n    }\n\n    return topologicalSort(result, x => x.id, x => x._dependencyIDs);\n  }\n}\n\n                                                           \nexport interface CloudAssemblyBuilderProps {\n                                                                                                      \n  readonly assetOutdir?: string;\n\n                                                                                                                                   \n  readonly parentBuilder?: CloudAssemblyBuilder;\n}\n\n                                                 \nexport class CloudAssemblyBuilder {\n                                                                    \n  public readonly outdir: string;\n\n                                                                                   \n  public readonly assetOutdir: string;\n\n  private readonly artifacts: { [id: string]: cxschema.ArtifactManifest } = { };\n  private readonly missing = new Array<cxschema.MissingContext>();\n  private readonly parentBuilder?: CloudAssemblyBuilder;\n\n                                                                                                                                     \n  constructor(outdir?: string, props: CloudAssemblyBuilderProps = {}) {\n    this.outdir = determineOutputDirectory(outdir);\n    this.assetOutdir = props.assetOutdir ?? this.outdir;\n    this.parentBuilder = props.parentBuilder;\n\n    // we leverage the fact that outdir is long-lived to avoid staging assets into it\n    // that were already staged (copying can be expensive). this is achieved by the fact\n    // that assets use a source hash as their name. other artifacts, and the manifest itself,\n    // will overwrite existing files as needed.\n    ensureDirSync(this.outdir);\n  }\n\n                                                                                                                                            \n  public addArtifact(id: string, manifest: cxschema.ArtifactManifest) {\n    this.artifacts[id] = filterUndefined(manifest);\n  }\n\n                                                                                                                                                                \n  public addMissing(missing: cxschema.MissingContext) {\n    if (this.missing.every(m => m.key !== missing.key)) {\n      this.missing.push(missing);\n    }\n    // Also report in parent\n    this.parentBuilder?.addMissing(missing);\n  }\n\n                                                                                                                                                                           \n  public buildAssembly(options: AssemblyBuildOptions = { }): CloudAssembly {\n\n    // explicitly initializing this type will help us detect\n    // breaking changes. (For example adding a required property will break compilation).\n    let manifest: cxschema.AssemblyManifest = {\n      version: cxschema.Manifest.version(),\n      artifacts: this.artifacts,\n      runtime: options.runtimeInfo,\n      missing: this.missing.length > 0 ? this.missing : undefined,\n    };\n\n    // now we can filter\n    manifest = filterUndefined(manifest);\n\n    const manifestFilePath = path.join(this.outdir, MANIFEST_FILE);\n    cxschema.Manifest.saveAssemblyManifest(manifest, manifestFilePath);\n\n    // \"backwards compatibility\": in order for the old CLI to tell the user they\n    // need a new version, we'll emit the legacy manifest with only \"version\".\n    // this will result in an error \"CDK Toolkit >= CLOUD_ASSEMBLY_VERSION is required in order to interact with this program.\"\n    fs.writeFileSync(path.join(this.outdir, 'cdk.out'), JSON.stringify({ version: manifest.version }));\n\n    return new CloudAssembly(this.outdir);\n  }\n\n                                                \n  public createNestedAssembly(artifactId: string, displayName: string) {\n    const directoryName = artifactId;\n    const innerAsmDir = path.join(this.outdir, directoryName);\n\n    this.addArtifact(artifactId, {\n      type: cxschema.ArtifactType.NESTED_CLOUD_ASSEMBLY,\n      properties: {\n        directoryName,\n        displayName,\n      } as cxschema.NestedCloudAssemblyProperties,\n    });\n\n    return new CloudAssemblyBuilder(innerAsmDir, {\n      // Reuse the same asset output directory as the current Casm builder\n      assetOutdir: this.assetOutdir,\n      parentBuilder: this,\n    });\n  }\n}\n\n                                                                                                                                                                                                                                                                 \nexport interface RuntimeInfo extends cxschema.RuntimeInfo {\n\n}\n\n                                                                                                                                                                                                                                                                      \nexport interface MetadataEntry extends cxschema.MetadataEntry {\n\n}\n\n                                                                                                                                                                                                                                                                           \nexport interface MissingContext {\n                                         \n  readonly key: string;\n\n                                                                                                                                                                                                                            \n  readonly provider: string;\n\n                                                                                                                                                                                             \n  readonly props: Record<string, any>;\n}\n\nexport interface AssemblyBuildOptions {\n                                                                                                                                                                                                                                                                                                               \n  readonly runtimeInfo?: RuntimeInfo;\n}\n\n/**\n * Returns a copy of `obj` without undefined values in maps or arrays.\n */\nfunction filterUndefined(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.filter(x => x !== undefined).map(x => filterUndefined(x));\n  }\n\n  if (typeof(obj) === 'object') {\n    const ret: any = { };\n    for (const [key, value] of Object.entries(obj)) {\n      if (value === undefined) {\n        continue;\n      }\n      ret[key] = filterUndefined(value);\n    }\n    return ret;\n  }\n\n  return obj;\n}\n\nfunction ignore(_x: any) {\n  return;\n}\n\n/**\n * Turn the given optional output directory into a fixed output directory\n */\nfunction determineOutputDirectory(outdir?: string) {\n  return outdir ?? fs.mkdtempSync(path.join(fs.realpathSync(os.tmpdir()), 'cdk.out'));\n}\n\nfunction ensureDirSync(dir: string) {\n  if (fs.existsSync(dir)) {\n    if (!fs.statSync(dir).isDirectory()) {\n      throw new Error(`${dir} must be a directory`);\n    }\n  } else {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n}"],
  "mappings": "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",
  "names": []
}
