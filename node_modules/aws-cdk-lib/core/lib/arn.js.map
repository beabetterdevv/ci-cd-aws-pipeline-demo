{
  "version": 3,
  "sources": ["arn.ts"],
  "sourcesContent": ["import { Fn } from './cfn-fn';\nimport { Stack } from './stack';\nimport { Token } from './token';\nimport { filterUndefined } from './util';\n\n                                                                                    \nexport enum ArnFormat {\n                                                                                                                                                                                                                                                                                                                \n  NO_RESOURCE_NAME = 'arn:aws:service:region:account:resource',\n\n                                                                                                                                                                                                                                                                                                                                                                                         \n  COLON_RESOURCE_NAME = 'arn:aws:service:region:account:resource:resourceName',\n\n                                                                                                                                                                                                                                                                                                                                                                                                                            \n  SLASH_RESOURCE_NAME = 'arn:aws:service:region:account:resource/resourceName',\n\n                                                                                                                                                                                                                                                                                                                                                                                  \n  SLASH_RESOURCE_SLASH_RESOURCE_NAME = 'arn:aws:service:region:account:/resource/resourceName',\n}\n\nexport interface ArnComponents {\n                                                                                                                                                                                                                                                                                                                                                      \n  readonly partition?: string;\n\n                                                                                                                      \n  readonly service: string;\n\n                                                                                                                                                                                                                    \n  readonly region?: string;\n\n                                                                                                                                                                                                                                                                                                \n  readonly account?: string;\n\n                                                                                                                                                                    \n  readonly resource: string;\n\n                                                                                                                                                                                                                                   \n  readonly sep?: string;\n\n                                                                                                                                                     \n  readonly resourceName?: string;\n\n                                                                                                                                                                                                                           \n  readonly arnFormat?: ArnFormat;\n}\n\nexport class Arn {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  public static format(components: ArnComponents, stack?: Stack): string {\n    const partition = components.partition ?? stack?.partition;\n    const region = components.region ?? stack?.region;\n    const account = components.account ?? stack?.account;\n\n    // Catch both 'null' and 'undefined'\n    if (partition == null || region == null || account == null) {\n      throw new Error(`Arn.format: partition (${partition}), region (${region}), and account (${account}) must all be passed if stack is not passed.`);\n    }\n\n    const sep = components.sep ?? (components.arnFormat === ArnFormat.COLON_RESOURCE_NAME ? ':' : '/');\n\n    const values = [\n      'arn', ':', partition, ':', components.service, ':', region, ':', account, ':',\n      ...(components.arnFormat === ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME ? ['/'] : []),\n      components.resource,\n    ];\n\n    if (sep !== '/' && sep !== ':' && sep !== '') {\n      throw new Error('resourcePathSep may only be \":\", \"/\" or an empty string');\n    }\n\n    if (components.resourceName != null) {\n      values.push(sep);\n      values.push(components.resourceName);\n    }\n\n    return values.join('');\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  public static parse(arn: string, sepIfToken: string = '/', hasName: boolean = true): ArnComponents {\n    let arnFormat: ArnFormat;\n    if (!hasName) {\n      arnFormat = ArnFormat.NO_RESOURCE_NAME;\n    } else {\n      arnFormat = sepIfToken === '/' ? ArnFormat.SLASH_RESOURCE_NAME : ArnFormat.COLON_RESOURCE_NAME;\n    }\n    return this.split(arn, arnFormat);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  public static split(arn: string, arnFormat: ArnFormat): ArnComponents {\n    const components = parseArnShape(arn);\n    if (components === 'token') {\n      return parseTokenArn(arn, arnFormat);\n    }\n\n    const [, partition, service, region, account, resourceTypeOrName, ...rest] = components;\n\n    let resource: string;\n    let resourceName: string | undefined;\n    let sep: string | undefined;\n    let resourcePartStartIndex = 0;\n    let detectedArnFormat: ArnFormat;\n\n    let slashIndex = resourceTypeOrName.indexOf('/');\n    if (slashIndex === 0) {\n      // new-style ARNs are of the form 'arn:aws:s4:us-west-1:12345:/resource-type/resource-name'\n      slashIndex = resourceTypeOrName.indexOf('/', 1);\n      resourcePartStartIndex = 1;\n      detectedArnFormat = ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME;\n    }\n    if (slashIndex !== -1) {\n      // the slash is only a separator if ArnFormat is not NO_RESOURCE_NAME\n      if (arnFormat === ArnFormat.NO_RESOURCE_NAME) {\n        sep = undefined;\n        slashIndex = -1;\n        detectedArnFormat = ArnFormat.NO_RESOURCE_NAME;\n      } else {\n        sep = '/';\n        detectedArnFormat = resourcePartStartIndex === 0\n          ? ArnFormat.SLASH_RESOURCE_NAME\n          // need to repeat this here, as otherwise the compiler thinks 'detectedArnFormat' is not initialized in all paths\n          : ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME;\n      }\n    } else if (rest.length > 0) {\n      sep = ':';\n      slashIndex = -1;\n      detectedArnFormat = ArnFormat.COLON_RESOURCE_NAME;\n    } else {\n      sep = undefined;\n      detectedArnFormat = ArnFormat.NO_RESOURCE_NAME;\n    }\n\n    if (slashIndex !== -1) {\n      resource = resourceTypeOrName.substring(resourcePartStartIndex, slashIndex);\n      resourceName = resourceTypeOrName.substring(slashIndex + 1);\n    } else {\n      resource = resourceTypeOrName;\n    }\n\n    if (rest.length > 0) {\n      if (!resourceName) {\n        resourceName = '';\n      } else {\n        resourceName += ':';\n      }\n\n      resourceName += rest.join(':');\n    }\n\n    // \"|| undefined\" will cause empty strings to be treated as \"undefined\".\n    // Optional ARN attributes (e.g. region, account) should return as empty string\n    // if they are provided as such.\n    return filterUndefined({\n      service: service || undefined,\n      resource: resource || undefined,\n      partition: partition || undefined,\n      region,\n      account,\n      resourceName,\n      sep,\n      arnFormat: detectedArnFormat,\n    });\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  public static extractResourceName(arn: string, resourceType: string): string {\n    const components = parseArnShape(arn);\n    if (components === 'token') {\n      return Fn.select(1, Fn.split(`:${resourceType}/`, arn));\n    }\n\n    // Apparently we could just parse this right away. Validate that we got the right\n    // resource type (to notify authors of incorrect assumptions right away).\n    const parsed = Arn.split(arn, ArnFormat.SLASH_RESOURCE_NAME);\n    if (!Token.isUnresolved(parsed.resource) && parsed.resource !== resourceType) {\n      throw new Error(`Expected resource type '${resourceType}' in ARN, got '${parsed.resource}' in '${arn}'`);\n    }\n    if (!parsed.resourceName) {\n      throw new Error(`Expected resource name in ARN, didn't find one: '${arn}'`);\n    }\n    return parsed.resourceName;\n  }\n\n  private constructor() { }\n}\n\n/**\n * Given a Token evaluating to ARN, parses it and returns components.\n *\n * The ARN cannot be validated, since we don't have the actual value yet\n * at the time of this function call. You will have to know the separator\n * and the type of ARN.\n *\n * The resulting `ArnComponents` object will contain tokens for the\n * subexpressions of the ARN, not string literals.\n *\n * WARNING: this function cannot properly parse the complete final\n * 'resourceName' part if it contains colons,\n * like 'arn:aws:cognito-sync:region:account:identitypool/us-east-1:1a1a1a1a-ffff-1111-9999-12345678:bla'.\n *\n * @param arnToken The input token that contains an ARN\n * @param arnFormat the expected format of 'arn' - depends on what format the service the ARN represents uses\n */\nfunction parseTokenArn(arnToken: string, arnFormat: ArnFormat): ArnComponents {\n  // ARN looks like:\n  // arn:partition:service:region:account:resource\n  // arn:partition:service:region:account:resource:resourceName\n  // arn:partition:service:region:account:resource/resourceName\n  // arn:partition:service:region:account:/resource/resourceName\n\n  const components = Fn.split(':', arnToken);\n\n  const partition = Fn.select(1, components).toString();\n  const service = Fn.select(2, components).toString();\n  const region = Fn.select(3, components).toString();\n  const account = Fn.select(4, components).toString();\n  let resource: string;\n  let resourceName: string | undefined;\n  let sep: string | undefined;\n\n  if (arnFormat === ArnFormat.NO_RESOURCE_NAME || arnFormat === ArnFormat.COLON_RESOURCE_NAME) {\n    // we know that the 'resource' part will always be the 6th segment in this case\n    resource = Fn.select(5, components);\n    if (arnFormat === ArnFormat.COLON_RESOURCE_NAME) {\n      resourceName = Fn.select(6, components);\n      sep = ':';\n    } else {\n      resourceName = undefined;\n      sep = undefined;\n    }\n  } else {\n    // we know that the 'resource' and 'resourceName' parts are separated by slash here,\n    // so we split the 6th segment from the colon-separated ones with a slash\n    const lastComponents = Fn.split('/', Fn.select(5, components));\n\n    if (arnFormat === ArnFormat.SLASH_RESOURCE_NAME) {\n      resource = Fn.select(0, lastComponents);\n      resourceName = Fn.select(1, lastComponents);\n    } else {\n      // arnFormat is ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME,\n      // which means there's an extra slash there at the beginning that we need to skip\n      resource = Fn.select(1, lastComponents);\n      resourceName = Fn.select(2, lastComponents);\n    }\n    sep = '/';\n  }\n\n  return { partition, service, region, account, resource, resourceName, sep, arnFormat };\n}\n\n/**\n * Validate that a string is either unparseable or looks mostly like an ARN\n */\nfunction parseArnShape(arn: string): 'token' | string[] {\n  // assume anything that starts with 'arn:' is an ARN,\n  // so we can report better errors\n  const looksLikeArn = arn.startsWith('arn:');\n\n  if (!looksLikeArn) {\n    if (Token.isUnresolved(arn)) {\n      return 'token';\n    } else {\n      throw new Error(`ARNs must start with \"arn:\" and have at least 6 components: ${arn}`);\n    }\n  }\n\n  // If the ARN merely contains Tokens, but otherwise *looks* mostly like an ARN,\n  // it's a string of the form 'arn:${partition}:service:${region}:${account}:resource/xyz'.\n  // Parse fields out to the best of our ability.\n  // Tokens won't contain \":\", so this won't break them.\n  const components = arn.split(':');\n\n  // const [/* arn */, partition, service, /* region */ , /* account */ , resource] = components;\n\n  const partition = components.length > 1 ? components[1] : undefined;\n  if (!partition) {\n    throw new Error('The `partition` component (2nd component) of an ARN is required: ' + arn);\n  }\n\n  const service = components.length > 2 ? components[2] : undefined;\n  if (!service) {\n    throw new Error('The `service` component (3rd component) of an ARN is required: ' + arn);\n  }\n\n  const resource = components.length > 5 ? components[5] : undefined;\n  if (!resource) {\n    throw new Error('The `resource` component (6th component) of an ARN is required: ' + arn);\n  }\n\n  // Region can be missing in global ARNs (such as used by IAM)\n\n  // Account can be missing in some ARN types (such as used for S3 buckets)\n\n  return components;\n}\n"],
  "mappings": "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",
  "names": []
}
