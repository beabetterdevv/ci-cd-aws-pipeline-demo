{
  "version": 3,
  "sources": ["cfn-resource.ts"],
  "sourcesContent": ["import * as cxapi from '../../cx-api';\nimport { CfnCondition } from './cfn-condition';\n// import required to be here, otherwise causes a cycle when running the generated JavaScript\n/* eslint-disable import/order */\nimport { CfnRefElement } from './cfn-element';\nimport { CfnCreationPolicy, CfnDeletionPolicy, CfnUpdatePolicy } from './cfn-resource-policy';\nimport { Construct, IConstruct, Node } from 'constructs';\nimport { addDependency } from './deps';\nimport { CfnReference } from './private/cfn-reference';\nimport { CLOUDFORMATION_TOKEN_RESOLVER } from './private/cloudformation-lang';\nimport { Reference } from './reference';\nimport { RemovalPolicy, RemovalPolicyOptions } from './removal-policy';\nimport { TagManager } from './tag-manager';\nimport { Tokenization } from './token';\nimport { capitalizePropertyNames, ignoreEmpty, PostResolveToken } from './util';\n\nexport interface CfnResourceProps {\n                                                                       \n  readonly type: string;\n\n                                                                                  \n  readonly properties?: { [name: string]: any };\n}\n\n                                                \nexport class CfnResource extends CfnRefElement {\n                                                                   \n  public static isCfnResource(construct: IConstruct): construct is CfnResource {\n    return (construct as any).cfnResourceType !== undefined;\n  }\n\n  // MAINTAINERS NOTE: this class serves as the base class for the generated L1\n  // (\"CFN\") resources (such as `s3.CfnBucket`). These resources will have a\n  // property for each CloudFormation property of the resource. This means that\n  // if at some point in the future a property is introduced with a name similar\n  // to one of the properties here, it will be \"masked\" by the derived class. To\n  // that end, we prefix all properties in this class with `cfnXxx` with the\n  // hope to avoid those conflicts in the future.\n\n                                                                                 \n  public readonly cfnOptions: ICfnResourceOptions = {};\n\n                                   \n  public readonly cfnResourceType: string;\n\n  /**\n   * AWS CloudFormation resource properties.\n   *\n   * This object is returned via cfnProperties\n   * @internal\n   */\n  protected readonly _cfnProperties: any;\n\n  /**\n   * An object to be merged on top of the entire resource definition.\n   */\n  private readonly rawOverrides: any = {};\n\n  /**\n   * Logical IDs of dependencies.\n   *\n   * Is filled during prepare().\n   */\n  private readonly dependsOn = new Set<CfnResource>();\n\n                                                                                                                                               \n  constructor(scope: Construct, id: string, props: CfnResourceProps) {\n    super(scope, id);\n\n    if (!props.type) {\n      throw new Error('The `type` property is required');\n    }\n\n    this.cfnResourceType = props.type;\n    this._cfnProperties = props.properties || {};\n\n    // if aws:cdk:enable-path-metadata is set, embed the current construct's\n    // path in the CloudFormation template, so it will be possible to trace\n    // back to the actual construct path.\n    if (Node.of(this).tryGetContext(cxapi.PATH_METADATA_ENABLE_CONTEXT)) {\n      this.addMetadata(cxapi.PATH_METADATA_KEY, Node.of(this).path);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  public applyRemovalPolicy(policy: RemovalPolicy | undefined, options: RemovalPolicyOptions = {}) {\n    policy = policy || options.default || RemovalPolicy.RETAIN;\n\n    let deletionPolicy;\n\n    switch (policy) {\n      case RemovalPolicy.DESTROY:\n        deletionPolicy = CfnDeletionPolicy.DELETE;\n        break;\n\n      case RemovalPolicy.RETAIN:\n        deletionPolicy = CfnDeletionPolicy.RETAIN;\n        break;\n\n      case RemovalPolicy.SNAPSHOT:\n        deletionPolicy = CfnDeletionPolicy.SNAPSHOT;\n        break;\n\n      default:\n        throw new Error(`Invalid removal policy: ${policy}`);\n    }\n\n    this.cfnOptions.deletionPolicy = deletionPolicy;\n    if (options.applyToUpdateReplacePolicy !== false) {\n      this.cfnOptions.updateReplacePolicy = deletionPolicy;\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                   \n  public getAtt(attributeName: string): Reference {\n    return CfnReference.for(this, attributeName);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  public addOverride(path: string, value: any) {\n    const parts = splitOnPeriods(path);\n    let curr: any = this.rawOverrides;\n\n    while (parts.length > 1) {\n      const key = parts.shift()!;\n\n      // if we can't recurse further or the previous value is not an\n      // object overwrite it with an object.\n      const isObject = curr[key] != null && typeof(curr[key]) === 'object' && !Array.isArray(curr[key]);\n      if (!isObject) {\n        curr[key] = {};\n      }\n\n      curr = curr[key];\n    }\n\n    const lastKey = parts.shift()!;\n    curr[lastKey] = value;\n  }\n\n                                                                                                                     \n  public addDeletionOverride(path: string) {\n    this.addOverride(path, undefined);\n  }\n\n                                                                                                                                                                                                                    \n  public addPropertyOverride(propertyPath: string, value: any) {\n    this.addOverride(`Properties.${propertyPath}`, value);\n  }\n\n                                                                                                                                                       \n  public addPropertyDeletionOverride(propertyPath: string) {\n    this.addPropertyOverride(propertyPath, undefined);\n  }\n\n                                                                                                                                                                                                                                                                                                                                          \n  public addDependsOn(target: CfnResource) {\n    // skip this dependency if the target is not part of the output\n    if (!target.shouldSynthesize()) {\n      return;\n    }\n\n    addDependency(this, target, `\"${Node.of(this).path}\" depends on \"${Node.of(target).path}\"`);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                \n  public addMetadata(key: string, value: any) {\n    if (!this.cfnOptions.metadata) {\n      this.cfnOptions.metadata = {};\n    }\n\n    this.cfnOptions.metadata[key] = value;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                             \n  public getMetadata(key: string): any {\n    return this.cfnOptions.metadata?.[key];\n  }\n\n                                                                  \n  public toString() {\n    return `${super.toString()} [${this.cfnResourceType}]`;\n  }\n\n  /**\n   * Called by the `addDependency` helper function in order to realize a direct\n   * dependency between two resources that are directly defined in the same\n   * stacks.\n   *\n   * Use `resource.addDependsOn` to define the dependency between two resources,\n   * which also takes stack boundaries into account.\n   *\n   * @internal\n   */\n  public _addResourceDependency(target: CfnResource) {\n    this.dependsOn.add(target);\n  }\n\n  /**\n   * Emits CloudFormation for this resource.\n   * @internal\n   */\n  public _toCloudFormation(): object {\n    if (!this.shouldSynthesize()) {\n      return { };\n    }\n\n    try {\n      const ret = {\n        Resources: {\n          // Post-Resolve operation since otherwise deepMerge is going to mix values into\n          // the Token objects returned by ignoreEmpty.\n          [this.logicalId]: new PostResolveToken({\n            Type: this.cfnResourceType,\n            Properties: ignoreEmpty(this.cfnProperties),\n            DependsOn: ignoreEmpty(renderDependsOn(this.dependsOn)),\n            CreationPolicy: capitalizePropertyNames(this, renderCreationPolicy(this.cfnOptions.creationPolicy)),\n            UpdatePolicy: capitalizePropertyNames(this, this.cfnOptions.updatePolicy),\n            UpdateReplacePolicy: capitalizePropertyNames(this, this.cfnOptions.updateReplacePolicy),\n            DeletionPolicy: capitalizePropertyNames(this, this.cfnOptions.deletionPolicy),\n            Version: this.cfnOptions.version,\n            Description: this.cfnOptions.description,\n            Metadata: ignoreEmpty(this.cfnOptions.metadata),\n            Condition: this.cfnOptions.condition && this.cfnOptions.condition.logicalId,\n          }, resourceDef => {\n            const renderedProps = this.renderProperties(resourceDef.Properties || {});\n            if (renderedProps) {\n              const hasDefined = Object.values(renderedProps).find(v => v !== undefined);\n              resourceDef.Properties = hasDefined !== undefined ? renderedProps : undefined;\n            }\n            const resolvedRawOverrides = Tokenization.resolve(this.rawOverrides, {\n              scope: this,\n              resolver: CLOUDFORMATION_TOKEN_RESOLVER,\n              // we need to preserve the empty elements here,\n              // as that's how removing overrides are represented as\n              removeEmpty: false,\n            });\n            return deepMerge(resourceDef, resolvedRawOverrides);\n          }),\n        },\n      };\n      return ret;\n    } catch (e) {\n      // Change message\n      e.message = `While synthesizing ${this.node.path}: ${e.message}`;\n      // Adjust stack trace (make it look like node built it, too...)\n      const trace = this.creationStack;\n      if (trace) {\n        const creationStack = ['--- resource created at ---', ...trace].join('\\n  at ');\n        const problemTrace = e.stack.substr(e.stack.indexOf(e.message) + e.message.length);\n        e.stack = `${e.message}\\n  ${creationStack}\\n  --- problem discovered at ---${problemTrace}`;\n      }\n\n      // Re-throw\n      throw e;\n    }\n\n    // returns the set of logical ID (tokens) this resource depends on\n    // sorted by construct paths to ensure test determinism\n    function renderDependsOn(dependsOn: Set<CfnResource>) {\n      return Array\n        .from(dependsOn)\n        .sort((x, y) => x.node.path.localeCompare(y.node.path))\n        .map(r => r.logicalId);\n    }\n\n    function renderCreationPolicy(policy: CfnCreationPolicy | undefined): any {\n      if (!policy) { return undefined; }\n      const result: any = { ...policy };\n      if (policy.resourceSignal && policy.resourceSignal.timeout) {\n        result.resourceSignal = policy.resourceSignal;\n      }\n      return result;\n    }\n  }\n\n  protected get cfnProperties(): { [key: string]: any } {\n    const props = this._cfnProperties || {};\n    if (TagManager.isTaggable(this)) {\n      const tagsProp: { [key: string]: any } = {};\n      tagsProp[this.tags.tagPropertyName] = this.tags.renderTags();\n      return deepMerge(props, tagsProp);\n    }\n    return props;\n  }\n\n  protected renderProperties(props: {[key: string]: any}): { [key: string]: any } {\n    return props;\n  }\n\n                                                                                                                                                                                                                 \n  protected get updatedProperites(): { [key: string]: any } {\n    return this._cfnProperties;\n  }\n\n  protected validateProperties(_properties: any) {\n    // Nothing\n  }\n\n                                                                                                                                                                                                                                                      \n  protected shouldSynthesize() {\n    return true;\n  }\n}\n\nexport enum TagType {\n  STANDARD = 'StandardTag',\n  AUTOSCALING_GROUP = 'AutoScalingGroupTag',\n  MAP = 'StringToStringMap',\n  KEY_VALUE = 'KeyValue',\n  NOT_TAGGABLE = 'NotTaggable',\n}\n\nexport interface ICfnResourceOptions {\n                                                                                                                                                                                                                                                                                                                         \n  condition?: CfnCondition;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  creationPolicy?: CfnCreationPolicy;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  deletionPolicy?: CfnDeletionPolicy;\n\n                                                                                                                                                                                                                                                                                                                                         \n  updatePolicy?: CfnUpdatePolicy;\n\n                                                                                                                                                                                                 \n  updateReplacePolicy?: CfnDeletionPolicy;\n\n                                                                                                                                                                                                                     \n  version?: string;\n\n                                                                                                                                                                                                                                                                          \n  description?: string;\n\n                                                                                                                                                                                                                                               \n  metadata?: { [key: string]: any };\n}\n\n/**\n * Merges `source` into `target`, overriding any existing values.\n * `null`s will cause a value to be deleted.\n */\nfunction deepMerge(target: any, ...sources: any[]) {\n  for (const source of sources) {\n    if (typeof(source) !== 'object' || typeof(target) !== 'object') {\n      throw new Error(`Invalid usage. Both source (${JSON.stringify(source)}) and target (${JSON.stringify(target)}) must be objects`);\n    }\n\n    for (const key of Object.keys(source)) {\n      const value = source[key];\n      if (typeof(value) === 'object' && value != null && !Array.isArray(value)) {\n        // if the value at the target is not an object, override it with an\n        // object so we can continue the recursion\n        if (typeof(target[key]) !== 'object') {\n          target[key] = {};\n        }\n\n        deepMerge(target[key], value);\n\n        // if the result of the merge is an empty object, it's because the\n        // eventual value we assigned is `undefined`, and there are no\n        // sibling concrete values alongside, so we can delete this tree.\n        const output = target[key];\n        if (typeof(output) === 'object' && Object.keys(output).length === 0) {\n          delete target[key];\n        }\n      } else if (value === undefined) {\n        delete target[key];\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Split on periods while processing escape characters \\\n */\nfunction splitOnPeriods(x: string): string[] {\n  // Build this list in reverse because it's more convenient to get the \"current\"\n  // item by doing ret[0] than by ret[ret.length - 1].\n  const ret = [''];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] === '\\\\' && i + 1 < x.length) {\n      ret[0] += x[i + 1];\n      i++;\n    } else if (x[i] === '.') {\n      ret.unshift('');\n    } else {\n      ret[0] += x[i];\n    }\n  }\n\n  ret.reverse();\n  return ret;\n}\n"],
  "mappings": "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",
  "names": []
}
